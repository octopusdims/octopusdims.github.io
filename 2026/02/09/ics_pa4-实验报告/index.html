<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>DIMS|ICS_PA4 实验报告</title>
<meta name=description content="🐙"><meta name=author content="OCTOPUS"><meta property="og:url" content="https://octopusdims.github.io/2026/02/09/ics_pa4-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"><meta property="og:site_name" content="DIMS"><meta property="og:title" content="ICS_PA4 实验报告"><meta property="og:description" content='实验进度 我已完成 PA4 的所有必做内容（虚实交错的魔法、分时多任务），成功实现了分页机制、进程上下文切换，并能够让仙剑奇侠传和 Hello 程序同时在 Nanos-lite 上分时运行。
必答题 分时多任务的具体过程 问题： 请结合代码, 解释分页机制和硬件中断是如何支撑仙剑奇侠传和hello程序在我们的计算机系统(Nanos-lite, AM, NEMU)中分时运行的。
Solution:
这一过程是时钟中断驱动与虚拟内存隔离共同作用的结果。我们可以将其拆解为以下几个关键步骤：
初始准备与加载 在 init_proc() 中（nanos-lite/src/proc.c:34-60），Nanos-lite 加载了仙剑奇侠传、Hello、Menu 和 Nterm 四个程序。
// pcb[0]: hello context_kload(&amp;pcb[0], hello_fun, "hello"); // pcb[1]: 仙剑奇侠传 (PAL) char *argv_pal[] = {"/bin/pal", "--skip", NULL}; char *envp_pal[] = {"PATH=/bin", NULL}; context_uload(&amp;pcb[1], "/bin/pal", argv_pal, envp_pal); 虚拟地址空间创建： context_uload 调用 protect()（am/src/riscv/nemu/vme.c:47-54），为每个进程分配独立的页目录表（Page Directory）并复制内核页表映射。 代码加载： Loader（nanos-lite/src/loader.c:49-100）将 ELF 文件加载到各自虚拟地址空间。通过 map() 函数建立虚拟地址到物理页帧的映射，确保不同进程的虚拟地址映射到不同的物理内存页。 中断触发 (The Trigger) 当仙剑奇侠传正在 CPU 上运行时，NEMU 的时钟设备定期产生中断信号（mcause = 0x80000007）。
硬件响应： 硬件检测到中断，保存当前 PC 到 mepc，设置 mcause，并跳转到 __am_asm_trap（位于 am/src/riscv/nemu/trap.S:44）。 保存现场 (Context Saving) trap.S（am/src/riscv/nemu/trap.S:44-94）将仙剑奇侠传当前的通用寄存器、CSR 寄存器（包括 mstatus, mepc 等）压入当前进程的内核栈中，形成一个 Context 结构体。'><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-09T22:45:00+00:00"><meta property="article:modified_time" content="2026-02-09T22:45:00+00:00"><meta property="article:tag" content="ICS"><meta property="article:tag" content="PA"><meta name=twitter:card content="summary"><meta name=twitter:title content="ICS_PA4 实验报告"><meta name=twitter:description content='实验进度 我已完成 PA4 的所有必做内容（虚实交错的魔法、分时多任务），成功实现了分页机制、进程上下文切换，并能够让仙剑奇侠传和 Hello 程序同时在 Nanos-lite 上分时运行。
必答题 分时多任务的具体过程 问题： 请结合代码, 解释分页机制和硬件中断是如何支撑仙剑奇侠传和hello程序在我们的计算机系统(Nanos-lite, AM, NEMU)中分时运行的。
Solution:
这一过程是时钟中断驱动与虚拟内存隔离共同作用的结果。我们可以将其拆解为以下几个关键步骤：
初始准备与加载 在 init_proc() 中（nanos-lite/src/proc.c:34-60），Nanos-lite 加载了仙剑奇侠传、Hello、Menu 和 Nterm 四个程序。
// pcb[0]: hello context_kload(&amp;pcb[0], hello_fun, "hello"); // pcb[1]: 仙剑奇侠传 (PAL) char *argv_pal[] = {"/bin/pal", "--skip", NULL}; char *envp_pal[] = {"PATH=/bin", NULL}; context_uload(&amp;pcb[1], "/bin/pal", argv_pal, envp_pal); 虚拟地址空间创建： context_uload 调用 protect()（am/src/riscv/nemu/vme.c:47-54），为每个进程分配独立的页目录表（Page Directory）并复制内核页表映射。 代码加载： Loader（nanos-lite/src/loader.c:49-100）将 ELF 文件加载到各自虚拟地址空间。通过 map() 函数建立虚拟地址到物理页帧的映射，确保不同进程的虚拟地址映射到不同的物理内存页。 中断触发 (The Trigger) 当仙剑奇侠传正在 CPU 上运行时，NEMU 的时钟设备定期产生中断信号（mcause = 0x80000007）。
硬件响应： 硬件检测到中断，保存当前 PC 到 mepc，设置 mcause，并跳转到 __am_asm_trap（位于 am/src/riscv/nemu/trap.S:44）。 保存现场 (Context Saving) trap.S（am/src/riscv/nemu/trap.S:44-94）将仙剑奇侠传当前的通用寄存器、CSR 寄存器（包括 mstatus, mepc 等）压入当前进程的内核栈中，形成一个 Context 结构体。'><script>(function(){document.documentElement.classList.add("dark"),localStorage.theme="dark"})()</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Noto+Serif+SC:wght@400;600;700&display=swap" rel=stylesheet><link rel=icon type=image/webp href=/images/favicon.webp><link rel=stylesheet href=/css/index.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script></head><body class=is-post><div class=floating-shapes><span class=shape style=--delay:0s;--x:15%;--y:25%>✦</span>
<span class=shape style=--delay:1.2s;--x:85%;--y:15%>○</span>
<span class=shape style=--delay:2.5s;--x:75%;--y:65%>✦</span>
<span class=shape style=--delay:0.8s;--x:10%;--y:55%>○</span>
<span class=shape style=--delay:1.8s;--x:90%;--y:45%>✦</span>
<span class=shape style=--delay:3s;--x:25%;--y:80%>○</span></div><header class=header data-glass-nav data-liquid-glass=header><div class=header-inner><a href=/ class=logo><span class=logo-text>DIMS</span></a><nav class=nav><a href=/archives class=nav-link>归档
</a><a href=/gallery class=nav-link>相册
</a><a href=/moments class=nav-link>日志
</a><a href=/about class=nav-link>关于</a></nav><div class=header-actions><button class="icon-btn search-toggle" aria-label=Search><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg></button></div></div></header><div class=search-modal id=searchModal><div class=search-container><div class=search-box><input type=text class=search-input id=searchInput placeholder=搜索文章... autocomplete=off>
<button class="icon-btn search-close" id=searchClose aria-label="Close search"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class=search-results id=searchResults></div><div class=search-footer><span class=search-hint>按 <kbd>ESC</kbd> 关闭</span>
<span class=search-hint><kbd>↑</kbd> <kbd>↓</kbd> 选择</span>
<span class=search-hint><kbd>Enter</kbd> 打开</span></div></div></div><main class=main><div class="layout layout-full"><section class="content content-full"><article class=post><div class=container><header class=post-header><h1 class=post-title>ICS_PA4 实验报告</h1><div class=post-meta><time class=post-date datetime=2026-02-09T22:45:00Z>2026年02月09日</time>
<span class=post-categories><a href=/categories/%E6%8A%A5%E5%91%8A/ class=category-link>报告</a>
</span><span class=post-wordcount>662 字</span></div></header><div class=post-body><aside class=post-toc><div class=toc-header><span class=toc-title>目录</span></div><div class=toc-content><nav id=TableOfContents><ul><li><a href=#实验进度>实验进度</a></li><li><a href=#必答题>必答题</a><ul><li><a href=#分时多任务的具体过程>分时多任务的具体过程</a></li><li><a href=#理解计算机系统-段错误分析>理解计算机系统 (段错误分析)</a></li></ul></li><li><a href=#思考题操作系统与未来>思考题：操作系统与未来</a><ul><li><a href=#关于-fork-的思考>关于 Fork 的思考</a></li><li><a href=#崩溃一致性-crash-consistency>崩溃一致性 (Crash Consistency)</a></li></ul></li><li><a href=#有趣的瞬间>有趣的瞬间</a><ul><li><a href=#成功运行分时多任务仙剑与-hello-并存>成功运行分时多任务：仙剑与 Hello 并存</a></li><li><a href=#见证虚拟内存的魔法同一个虚拟地址不同的物理数据>见证虚拟内存的魔法：同一个虚拟地址，不同的物理数据</a></li><li><a href=#调试-traps-的艰辛>调试 trap.S 的艰辛</a></li></ul></li><li><a href=#实验心情>实验心情</a></li></ul></nav></div></aside><div class=post-content><h2 id=实验进度>实验进度</h2><p>我已完成 PA4 的<strong>所有必做内容</strong>（虚实交错的魔法、分时多任务），成功实现了分页机制、进程上下文切换，并能够让<strong>仙剑奇侠传</strong>和 <strong>Hello</strong> 程序同时在 Nanos-lite 上分时运行。</p><hr><h2 id=必答题>必答题</h2><h3 id=分时多任务的具体过程>分时多任务的具体过程</h3><p><strong>问题：</strong> 请结合代码, 解释分页机制和硬件中断是如何支撑仙剑奇侠传和hello程序在我们的计算机系统(Nanos-lite, AM, NEMU)中分时运行的。</p><p><strong>Solution:</strong></p><p>这一过程是<strong>时钟中断驱动</strong>与<strong>虚拟内存隔离</strong>共同作用的结果。我们可以将其拆解为以下几个关键步骤：</p><h4 id=初始准备与加载>初始准备与加载</h4><p>在 <code>init_proc()</code> 中（<code>nanos-lite/src/proc.c:34-60</code>），Nanos-lite 加载了仙剑奇侠传、Hello、Menu 和 Nterm 四个程序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// pcb[0]: hello 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>context_kload</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pcb</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>hello_fun</span><span class=p>,</span> <span class=s>&#34;hello&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// pcb[1]: 仙剑奇侠传 (PAL)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=o>*</span><span class=n>argv_pal</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;/bin/pal&#34;</span><span class=p>,</span> <span class=s>&#34;--skip&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>envp_pal</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;PATH=/bin&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nf>context_uload</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pcb</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=s>&#34;/bin/pal&#34;</span><span class=p>,</span> <span class=n>argv_pal</span><span class=p>,</span> <span class=n>envp_pal</span><span class=p>);</span>
</span></span></code></pre></div><ul><li><strong>虚拟地址空间创建：</strong> <code>context_uload</code> 调用 <code>protect()</code>（<code>am/src/riscv/nemu/vme.c:47-54</code>），为每个进程分配独立的页目录表（Page Directory）并复制内核页表映射。</li><li><strong>代码加载：</strong> Loader（<code>nanos-lite/src/loader.c:49-100</code>）将 ELF 文件加载到各自虚拟地址空间。通过 <code>map()</code> 函数建立虚拟地址到物理页帧的映射，确保不同进程的虚拟地址映射到不同的物理内存页。</li></ul><h4 id=中断触发-the-trigger>中断触发 (The Trigger)</h4><p>当仙剑奇侠传正在 CPU 上运行时，NEMU 的时钟设备定期产生中断信号（<code>mcause = 0x80000007</code>）。</p><ul><li><strong>硬件响应：</strong> 硬件检测到中断，保存当前 PC 到 <code>mepc</code>，设置 <code>mcause</code>，并跳转到 <code>__am_asm_trap</code>（位于 <code>am/src/riscv/nemu/trap.S:44</code>）。</li></ul><h4 id=保存现场-context-saving>保存现场 (Context Saving)</h4><p><code>trap.S</code>（<code>am/src/riscv/nemu/trap.S:44-94</code>）将仙剑奇侠传当前的通用寄存器、CSR 寄存器（包括 <code>mstatus</code>, <code>mepc</code> 等）压入当前进程的内核栈中，形成一个 <code>Context</code> 结构体。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>__am_asm_trap:</span>
</span></span><span class=line><span class=cl>  <span class=nf>csrrw</span> <span class=no>sp</span><span class=p>,</span> <span class=no>mscratch</span><span class=p>,</span> <span class=no>sp</span>    <span class=c1># 交换sp和mscratch，从用户态切换到内核态
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>bnez</span> <span class=no>sp</span><span class=p>,</span> <span class=no>.from_user</span>       <span class=c1># 如果mscratch非零，说明来自用户态
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=na>...</span>
</span></span><span class=line><span class=cl><span class=nl>.from_user:</span>
</span></span><span class=line><span class=cl>  <span class=nf>addi</span> <span class=no>sp</span><span class=p>,</span> <span class=no>sp</span><span class=p>,</span> <span class=p>-</span><span class=no>CONTEXT_SIZE</span>
</span></span><span class=line><span class=cl>  <span class=nf>MAP</span><span class=p>(</span><span class=no>REGS</span><span class=p>,</span> <span class=no>PUSH</span><span class=p>)</span>           <span class=c1># 保存所有通用寄存器
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>csrr</span> <span class=no>t0</span><span class=p>,</span> <span class=no>mscratch</span>
</span></span><span class=line><span class=cl>  <span class=nf>csrw</span> <span class=no>mscratch</span><span class=p>,</span> <span class=no>zero</span>
</span></span><span class=line><span class=cl>  <span class=nf>STORE</span> <span class=no>t0</span><span class=p>,</span> <span class=no>OFFSET_SP</span><span class=p>(</span><span class=no>sp</span><span class=p>)</span>   <span class=c1># 保存用户态sp
</span></span></span></code></pre></div><ul><li>此时保存的上下文包含该进程的地址空间标识（RISC-V 中为 <code>satp</code> 寄存器，通过 <code>__am_get_cur_as()</code> 保存到 <code>c->pdir</code>）。</li></ul><h4 id=进程调度-scheduling>进程调度 (Scheduling)</h4><p>控制权传递给 C 代码 <code>__am_irq_handle</code>（<code>am/src/riscv/nemu/cte.c:8-29</code>），最终调用 <code>schedule()</code>（<code>nanos-lite/src/proc.c:62-90</code>）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>Context</span><span class=o>*</span> <span class=nf>schedule</span><span class=p>(</span><span class=n>Context</span> <span class=o>*</span><span class=n>prev</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>current</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span><span class=o>-&gt;</span><span class=n>cp</span> <span class=o>=</span> <span class=n>prev</span><span class=p>;</span>      <span class=c1>// 保存当前上下文
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 简单的轮转调度，支持前台进程权重
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>weight</span> <span class=o>=</span> <span class=p>(</span><span class=n>current</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>pcb</span><span class=p>[</span><span class=n>fg_pcb</span><span class=p>])</span> <span class=o>?</span> <span class=nl>FG_WEIGHT</span> <span class=p>:</span> <span class=n>HELLO_WEIGHT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>current_t</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=kt>current_t</span> <span class=o>&gt;=</span> <span class=n>weight</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>current_t</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>current</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>pcb</span><span class=p>[</span><span class=n>fg_pcb</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>current</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>pcb</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>     <span class=c1>// 切换到hello
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>current</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>pcb</span><span class=p>[</span><span class=n>fg_pcb</span><span class=p>];</span> <span class=c1>// 切换回前台进程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>cp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=上下文切换与地址空间切换-the-switch>上下文切换与地址空间切换 (The Switch)</h4><p>这是最神奇的一步，发生在 <code>__am_switch()</code>（<code>am/src/riscv/nemu/vme.c:63-71</code>）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>__am_switch</span><span class=p>(</span><span class=n>Context</span> <span class=o>*</span><span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>vme_enable</span> <span class=o>&amp;&amp;</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>pdir</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>set_satp</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>pdir</span><span class=p>);</span>       <span class=c1>// 设置satp寄存器，切换页表
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>set_satp</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>pdir</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uintptr_t</span> <span class=n>mode</span> <span class=o>=</span> <span class=mi>1ul</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>__riscv_xlen</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>asm</span> <span class=k>volatile</span><span class=p>(</span><span class=s>&#34;csrw satp, %0&#34;</span> <span class=o>:</span> <span class=o>:</span> <span class=s>&#34;r&#34;</span><span class=p>(</span><span class=n>mode</span> <span class=o>|</span> <span class=p>((</span><span class=kt>uintptr_t</span><span class=p>)</span><span class=n>pdir</span> <span class=o>&gt;&gt;</span> <span class=mi>12</span><span class=p>)));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><strong>栈切换：</strong> 栈指针 <code>sp</code> 被修改为 Hello 进程的上下文地址（在 <code>trap.S</code> 中通过 <code>mv sp, a0</code> 恢复）。</li><li><strong>地址空间切换：</strong> 从 Hello 的上下文中恢复 <code>pdir</code> 到硬件的 MMU 基址寄存器 <code>satp</code>。</li><li><strong>瞬间变化：</strong> 一旦 <code>satp</code> 改变，CPU 看到的“整个世界”（内存映射）瞬间变了。原本属于仙剑的虚拟地址 <code>0x40000000</code> 可能映射到物理页 X，而现在同样的虚拟地址 <code>0x40000000</code> 映射到了物理页 Y（Hello 的代码）。</li></ul><h4 id=恢复现场-restoration>恢复现场 (Restoration)</h4><p><code>trap.S</code>（<code>am/src/riscv/nemu/trap.S:78-94</code>）执行 <code>POP</code> 操作，将 Hello 进程之前冻结的寄存器值恢复到 CPU 中，最后执行 <code>mret</code>。CPU 跳转到 Hello 程序的 <code>PC</code> 继续执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>  <span class=nf>LOAD</span> <span class=no>t1</span><span class=p>,</span> <span class=no>OFFSET_STATUS</span><span class=p>(</span><span class=no>sp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>LOAD</span> <span class=no>t2</span><span class=p>,</span> <span class=no>OFFSET_EPC</span><span class=p>(</span><span class=no>sp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>csrw</span> <span class=no>mstatus</span><span class=p>,</span> <span class=no>t1</span>
</span></span><span class=line><span class=cl>  <span class=nf>csrw</span> <span class=no>mepc</span><span class=p>,</span> <span class=no>t2</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nf>LOAD</span> <span class=no>t0</span><span class=p>,</span> <span class=no>OFFSET_SP</span><span class=p>(</span><span class=no>sp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>csrw</span> <span class=no>mscratch</span><span class=p>,</span> <span class=no>t0</span>     <span class=c1># 恢复用户态sp到mscratch
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=nf>MAP</span><span class=p>(</span><span class=no>REGS</span><span class=p>,</span> <span class=no>POP</span><span class=p>)</span>        <span class=c1># 恢复所有通用寄存器
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>addi</span> <span class=no>sp</span><span class=p>,</span> <span class=no>sp</span><span class=p>,</span> <span class=no>CONTEXT_SIZE</span>
</span></span><span class=line><span class=cl>  <span class=na>...</span>
</span></span><span class=line><span class=cl>  <span class=nf>mret</span>                  <span class=c1># 返回到用户态
</span></span></span></code></pre></div><p><strong>总结：</strong> 分页机制保证了两个程序在内存中互不干扰（空间隔离），时钟中断保证了控制权能周期性地回到操作系统手中（时间共享），从而实现了“同时”运行的错觉。</p><hr><h3 id=理解计算机系统-段错误分析>理解计算机系统 (段错误分析)</h3><p><strong>问题：</strong> 尝试在Linux中编写并运行以下程序:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=s>&#34;abc&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;A&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>你会看到程序因为往只读字符串进行写入而触发了段错误。请你根据学习的知识和工具，从程序, 编译器, 链接器, 运行时环境, 操作系统和硬件等视角分析"字符串的写保护机制是如何实现的"。</p><p><strong>Solution:</strong>
<img src=Segmentation_Fault.png alt=报错信息>
段错误（Segmentation Fault）的发生是计算机系统各层级通力合作的结果，旨在保护内存安全。</p><ol><li><strong>程序层 (C Language)</strong></li></ol><ul><li>在 C 语言语义中，<code>"abc"</code> 是一个<strong>字符串字面量 (String Literal)</strong>。</li><li>根据 C 标准，修改字符串字面量的行为是 <strong>Undefined Behavior (UB)</strong>。</li><li>变量 <code>p</code> 只是一个指针，它指向了这个字面量的首地址。</li></ul><ol start=2><li><strong>编译器层 (Compiler - GCC)</strong></li></ol><ul><li>GCC 在编译源代码时，会将字符串字面量 <code>"abc"</code> 放置在特定的 <strong>Section</strong> 中。</li><li>通常，这个 Section 是 <code>.rodata</code> (Read-Only Data)。</li><li>我们可以通过 <code>objdump -s</code> 查看目标文件，发现 <code>"abc"</code> 确实位于 <code>.rodata</code> 段。
<img src=objdump.png alt=objdump结果></li></ul><ol><li><strong>链接器层 (Linker - LD)</strong></li></ol><ul><li>链接器将多个目标文件合并为可执行文件 (ELF)。</li><li>它会将所有的 <code>.rodata</code> section 合并到一个 <strong>Segment</strong> 中。</li><li><strong>关键点：</strong> 链接器会将这个 Segment 标记为 <strong>Read-Only (R)</strong>。</li><li><strong>工具验证：</strong> 使用 <code>readelf -l test</code> 可以看到对应的 <code>LOAD</code> Segment 的 <code>Flg</code> 只有 <code>R</code> (Read)，没有 <code>W</code> (Write)。
<img src=readelf.png alt=readelf结果></li></ul><ol><li><strong>运行时环境/加载器层 (Loader - OS)</strong></li></ol><ul><li>当 Linux 执行该程序时，Loader 读取 ELF Header。</li><li>Loader 请求内核分配物理内存，并建立虚拟内存映射。</li><li><strong>关键动作：</strong> Loader 告知内核，这段包含 <code>"abc"</code> 的虚拟内存页，其<strong>权限必须严格设置为只读</strong>。</li></ul><ol><li><strong>硬件层 (Hardware - MMU)</strong></li></ol><ul><li>当程序执行到 <code>p[0] = 'A'</code> 时，CPU 发出一条 <code>STORE</code> 指令，试图向虚拟地址 <code>p</code> 写入数据。</li><li><strong>MMU (Memory Management Unit)</strong> 拦截该请求，查询 TLB 或页表 (Page Table)。</li><li>MMU 发现该虚拟地址对应的 <strong>PTE (Page Table Entry)</strong> 中的权限位（Permission Bits）禁止写入 (<code>Valid=1</code>, <code>Write=0</code>)。</li><li>MMU 触发硬件异常（在 x86 上是 Page Fault，RISC-V 上是 Store Access Fault）。</li></ul><ol start=6><li><strong>操作系统层 (OS - Kernel)</strong></li></ol><ul><li>CPU 捕获异常，陷入内核态。</li><li>内核的 Page Fault Handler 检查出错原因。它发现这是一次<strong>合法的映射</strong>（地址有效），但是<strong>权限违规</strong>（试图写只读页）。</li><li>内核判定该进程非法操作，向该进程发送 <strong><code>SIGSEGV</code></strong> 信号。</li><li>进程收到信号，若无自定义处理，默认行为是 <strong>Core Dump</strong> 并终止运行。</li></ul><p><strong>结论：</strong> “写保护”是从 ELF 文件头部的标志位开始，一路传递到页表项的硬件权限位，最终由 MMU 硬件强制执行的铁律。</p><hr><h2 id=思考题操作系统与未来>思考题：操作系统与未来</h2><h3 id=关于-fork-的思考>关于 Fork 的思考</h3><p>讲义中提到 Nanos-lite 难以实现 <code>fork()</code>。通过 PA4 的学习，我理解到 <code>fork()</code> 的核心在于<strong>地址空间的写时复制 (Copy-On-Write, COW)</strong>。</p><p>如果直接完整复制父进程的物理内存给子进程，效率极低。现代 OS 通过将父子进程的页表项都设为“只读”，当任意一方尝试写入时，MMU 触发异常，OS 此时才分配新的物理页并复制数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// COW 的简化流程示意：
</span></span></span><span class=line><span class=cl><span class=c1>// 1. fork时，父子共享物理页，PTE都设为只读
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>map</span><span class=p>(</span><span class=n>parent_pgdir</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=n>pa</span><span class=p>,</span> <span class=n>PTE_R</span><span class=p>);</span>  <span class=c1>// 只读
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>map</span><span class=p>(</span><span class=n>child_pgdir</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=n>pa</span><span class=p>,</span> <span class=n>PTE_R</span><span class=p>);</span>   <span class=c1>// 同样映射，只读
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 2. 任一进程写入时触发Page Fault
</span></span></span><span class=line><span class=cl><span class=c1>// 3. OS处理：分配新页、复制数据、更新页表为可写
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>*</span><span class=n>new_pa</span> <span class=o>=</span> <span class=nf>pgalloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nf>memcpy</span><span class=p>(</span><span class=n>new_pa</span><span class=p>,</span> <span class=n>pa</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>map</span><span class=p>(</span><span class=n>pgdir</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=n>new_pa</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>  <span class=c1>// 现在可写
</span></span></span></code></pre></div><p>这在我的 Nanos-lite 中需要极强的内存管理模块支持，目前的实现还显得过于单薄。</p><h3 id=崩溃一致性-crash-consistency>崩溃一致性 (Crash Consistency)</h3><p>在做文件系统实验时，我意识到仅仅把数据 <code>write</code> 进 buffer 并不安全。如果此时断电，数据就丢了。真正的文件系统（如 ext4, NTFS）需要 <strong>Journaling (日志)</strong> 机制，先记录“我要修改数据”这件事，再修改数据。这样即使断电，重启后也能根据日志恢复现场，保证文件系统不损坏。这让我对 PA3 中简单的文件系统有了更深的敬畏。</p><hr><h2 id=有趣的瞬间>有趣的瞬间</h2><h3 id=成功运行分时多任务仙剑与-hello-并存>成功运行分时多任务：仙剑与 Hello 并存</h3><p><img src=final1.png alt=多进程抢占式></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// proc.c 中的调度配置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define FG_WEIGHT     100   </span><span class=c1>// 前台进程权重（仙剑）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define HELLO_WEIGHT  1     </span><span class=c1>// 后台进程权重（Hello）
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 当仙剑运行时，每100个时间片才切换一次
</span></span></span><span class=line><span class=cl><span class=c1>// 当Hello运行时，每1个时间片就切换回仙剑
</span></span></span></code></pre></div><p><img src=final2.png alt=多个进程></p><h3 id=见证虚拟内存的魔法同一个虚拟地址不同的物理数据>见证虚拟内存的魔法：同一个虚拟地址，不同的物理数据</h3><p>在调试时，我观察到两个进程的页表（<code>satp</code>）指向不同的页目录，相同的虚拟地址 <code>0x40000000</code>（程序入口）却取到了不同的指令，这就是分页机制的威力。</p><h3 id=调试-traps-的艰辛>调试 trap.S 的艰辛</h3><p>在实验过程中，我修复了 <code>trap.S</code> 中的 bug。问题出在用户态和内核态的栈切换逻辑：</p><ul><li>必须正确使用 <code>mscratch</code> 寄存器保存用户态栈指针</li><li>从用户态进入时要交换 <code>sp</code> 和 <code>mscratch</code></li><li>恢复时要确保 <code>mscratch</code> 重新指向用户栈</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>csrrw</span> <span class=no>sp</span><span class=p>,</span> <span class=no>mscratch</span><span class=p>,</span> <span class=no>sp</span>    <span class=c1># 进入时交换
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=na>...</span>
</span></span><span class=line><span class=cl><span class=nf>csrrw</span> <span class=no>sp</span><span class=p>,</span> <span class=no>mscratch</span><span class=p>,</span> <span class=no>sp</span>    <span class=c1># 退出时交换回来
</span></span></span></code></pre></div><hr><h2 id=实验心情>实验心情</h2><blockquote><p>🤯 <strong>痛并快乐着。</strong></p></blockquote><p>PA4 是整个 PA 系列中难度陡增的一章。从理解 <code>satp</code> 寄存器如何切换“世界”，到调试各种玄学的 Page Fault，过程非常痛苦😭。特别是处理上下文切换时，栈指针 <code>sp</code> 只要错一个字节，整个系统就会莫名其妙地跑飞。</p><p>但当我在 Nanos-lite 上看到仙剑的画面流畅运行，而后台的 Hello 依然在顽强地输出字符时，那种对“并发”和“虚拟化”的理解瞬间具象化了。以前觉得高深莫测的概念，现在变成了我指尖的代码。</p><p><strong>I have truly created a world.</strong></p></div></div><footer class=post-footer><div class=post-tags><a href=/tags/ics/ class=tag-link>#ICS</a>
<a href=/tags/pa/ class=tag-link>#PA</a></div></footer></div></article></section></div></main><footer class=footer data-liquid-glass=footer><div class=container><div class=footer-inner><div class=footer-info><p class=copyright>© 2025 - 2026 OCTOPUS</p><p class=powered>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> & Designed By Myself
       </p></div></div></div></footer><button class=fab-sidebar-toggle id=fabSidebarToggle aria-label=打开侧边栏><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class=sidebar-drawer id=sidebarDrawer><div class=sidebar-drawer-header><span class=sidebar-drawer-title>导航</span>
<button class=sidebar-drawer-close id=sidebarDrawerClose aria-label=关闭><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class=sidebar-drawer-content><div class=sidebar-inner><div class="sidebar-card blog-title-card"><a href=/ class=blog-title-link><span class=blog-title-text>DIMS</span></a></div><div class="sidebar-card profile-card"><div class=avatar><img src="https://avatars.githubusercontent.com/u/204014295?v=4" alt=OCTOPUS></div><div class=profile-info><h3>OCTOPUS</h3><p>热爱技术，热爱生活。</p></div><div class=profile-meta><span>Since 2025</span>
<span>github</span></div><nav class=mobile-nav><a href=/archives class=mobile-nav-link><span class=mobile-nav-icon>📁
</span><span>归档</span>
</a><a href=/gallery class=mobile-nav-link><span class=mobile-nav-icon>🖼️
</span><span>相册</span>
</a><a href=/moments class=mobile-nav-link><span class=mobile-nav-icon>📝
</span><span>日志</span>
</a><a href=/about class=mobile-nav-link><span class=mobile-nav-icon>👤
</span><span>关于</span></a></nav></div><div class=sidebar-card><h4 class=sidebar-title><a href=/categories/ class=sidebar-title-link><span class=title-icon>📁</span>
<span>分类</span></a></h4><ul class=sidebar-list><li><a href=/categories/%E6%8A%A5%E5%91%8A/ class=sidebar-link><span class=link-name>报告</span>
<span class=count>4</span></a></li></ul></div><div class=sidebar-card><h4 class=sidebar-title><a href=/tags/ class=sidebar-title-link><span class=title-icon>🏷️</span>
<span>标签</span></a></h4><div class=tag-cloud-compact><a href=/tags/ics/ class=tag-item-compact title="4 篇文章">ICS
</a><a href=/tags/pa/ class=tag-item-compact title="4 篇文章">PA</a></div></div><div class=sidebar-card><h4 class=sidebar-title><span class=title-icon>📝</span>
<span>最近文章</span></h4><ul class="sidebar-list recent-posts"><li><a href=/2026/02/09/ics_pa4-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/ class="sidebar-link recent-post-link"><span class="link-name recent-post-title">ICS_PA4 实验报告</span>
<span class=date>02-09</span></a></li><li><a href=/2025/12/12/ics_pa3-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/ class="sidebar-link recent-post-link"><span class="link-name recent-post-title">ICS_PA3 实验报告</span>
<span class=date>12-12</span></a></li><li><a href=/2025/11/11/ics_pa2-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/ class="sidebar-link recent-post-link"><span class="link-name recent-post-title">ICS_PA2 实验报告</span>
<span class=date>11-11</span></a></li><li><a href=/2025/09/24/ics_pa1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/ class="sidebar-link recent-post-link"><span class="link-name recent-post-title">ICS_PA1 实验报告</span>
<span class=date>09-24</span></a></li></ul></div></div></div></div><div class=sidebar-overlay id=sidebarOverlay></div><script src=/js/liquidGlass.min.js></script><script src=/js/main.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){typeof renderMathInElement!="undefined"&&renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script></body></html>