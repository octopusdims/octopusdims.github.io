(function(){"use strict";if(!document.documentElement.classList.contains("dark"))return;if(!document.createElement("canvas").getContext("webgl2"))return;function i(e,t,n){return e+(t-e)*n}const n=`#version 300 es
    precision highp float;
    layout(location = 0) in vec2 a_position;
    out vec2 v_uv;
    out vec2 v_px;
    uniform vec2 u_resolution;
    void main() {
      v_uv = a_position * 0.5 + 0.5;
      v_px = v_uv * u_resolution;
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `,s=`#version 300 es
    precision highp float;
    in vec2 v_uv;
    in vec2 v_px;
    out vec4 fragColor;
    
    uniform vec2 u_resolution;
    uniform float u_time;
    uniform vec2 u_mouse;
    uniform vec2 u_mouseVel;
    uniform float u_hover;
    uniform vec3 u_baseColor;
    uniform float u_cornerRadius;
    
    #define PI 3.14159
    
    vec3 mod289(vec3 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
    vec2 mod289(vec2 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
    vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
    
    float snoise(vec2 v) {
      const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                         -0.577350269189626, 0.024390243902439);
      vec2 i = floor(v + dot(v, C.yy));
      vec2 x0 = v - i + dot(i, C.xx);
      vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
      vec4 x12 = x0.xyxy + C.xxzz;
      x12.xy -= i1;
      i = mod289(i);
      vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
      vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
      m = m*m; m = m*m;
      vec3 x = 2.0 * fract(p * C.www) - 1.0;
      vec3 h = abs(x) - 0.5;
      vec3 ox = floor(x + 0.5);
      vec3 a0 = x - ox;
      m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
      vec3 g;
      g.x = a0.x * x0.x + h.x * x0.y;
      g.yz = a0.yz * x12.xz + h.yz * x12.yw;
      return 130.0 * dot(m, g);
    }
    
    // Smooth lens distortion
    vec2 lensDistort(vec2 p, vec2 center, float strength, float radius) {
      vec2 delta = p - center;
      float dist = length(delta);
      float fac = smoothstep(radius, 0.0, dist) * strength;
      // Smooth quadratic distortion
      float distort = fac * (1.0 + dist * 0.001);
      return delta * distort;
    }
    
    // Smooth gradient noise
    float smoothNoise(vec2 p) {
      float n = snoise(p * 0.5) * 0.5;
      n += snoise(p * 1.0) * 0.25;
      n += snoise(p * 2.0) * 0.125;
      return n;
    }
    
    // Rounded rect SDF
    float sdRoundRect(vec2 p, vec2 b, float r) {
      vec2 d = abs(p) - b + vec2(r);
      return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;
    }
    
    void main() {
      vec2 px = v_px;
      vec2 center = u_resolution * 0.5;
      vec2 local = px - center;
      
      // Shape
      vec2 halfSize = u_resolution * 0.5 - vec2(2.0);
      float shapeDist = sdRoundRect(local, halfSize, u_cornerRadius);
      float edgeDist = abs(shapeDist);
      float shapeAlpha = 1.0 - smoothstep(-1.0, 1.0, shapeDist);
      float edgeFactor = smoothstep(60.0, 0.0, edgeDist);
      
      float t = u_time * 0.3;
      
      // === REFINED MOUSE FLUID FLOW ===
      vec2 mousePos = u_mouse * u_resolution;
      
      // Curl noise for natural fluid motion
      vec2 uv = px * 0.003;
      float n1 = snoise(uv + t * 0.1);
      float n2 = snoise(uv * 1.5 + t * 0.08 + 100.0);
      float n3 = snoise(uv * 0.5 - t * 0.05 + 200.0);
      
      // Curl from noise gradient
      vec2 curl;
      curl.x = n2 - n1;
      curl.y = n3 - n2;
      curl = normalize(curl + 0.001) * length(vec2(n1, n2)) * 40.0;
      
      // Slow organic undulation
      vec2 slowUV = px * 0.001 + t * 0.03;
      vec2 slowFlow = vec2(
        snoise(slowUV + vec2(0.01, 0.0)) - snoise(slowUV - vec2(0.01, 0.0)),
        snoise(slowUV + vec2(0.0, 0.01)) - snoise(slowUV - vec2(0.0, 0.01))
      ) * 50.0;
      
      // === TEXTURE MODULATION ===
      // Mouse modulation UV offset - texture pattern unchanged, position slightly shifted
      vec2 toMouse = px - mousePos;
      float mouseDist = length(toMouse);
      vec2 mouseDir = normalize(toMouse + 0.001);
      
      // Get mouse velocity
      vec2 mouseVelocity = u_mouseVel * u_resolution;
      float mouseSpeed = length(mouseVelocity);
      vec2 velDir = normalize(mouseVelocity + 0.001);
      
      float influenceRadius = 180.0;
      float baseInfluence = smoothstep(influenceRadius, 0.0, mouseDist) * u_hover;
      
      // Velocity influence - use smooth curve to avoid linear abruptness
      float speedFactor = smoothstep(0.0, 0.05, mouseSpeed) * min(mouseSpeed * 10.0, 1.0);
      float influence = baseInfluence * (1.0 + speedFactor * 0.5);
      
      // Base organic disturbance (always present)
      float timeFlow = t * 0.15;
      vec2 organicOffset = vec2(
        snoise(vec2(uv.x * 0.5 + timeFlow, uv.y * 0.3)),
        snoise(vec2(uv.x * 0.3, uv.y * 0.5 + timeFlow))
      ) * 0.3;
      
      // Trail effect - natural flow based on movement direction
      vec2 trailOffset = vec2(0.0);
      if (mouseSpeed > 0.001) {
        // Calculate position relative to mouse movement path
        float alongPath = dot(toMouse, velDir);
        float acrossDist = length(toMouse - velDir * alongPath);
        
        // Trail area: rear fan-shaped region
        float behindFactor = smoothstep(20.0, -80.0, alongPath); // behind
        float widthFactor = smoothstep(120.0, 0.0, acrossDist);   // width
        float trailInfluence = behindFactor * widthFactor * speedFactor;
        
        // Trail texture flow - use noise to create organic shapes
        float trailPhase = acrossDist * 0.02 - alongPath * 0.01 - t * 1.5;
        float trailWave = sin(trailPhase) * 0.5 + 0.5;
        trailWave *= exp(-acrossDist * 0.008); // edge attenuation
        
        // Flow perpendicular to movement direction
        vec2 perpDir = vec2(-velDir.y, velDir.x);
        trailOffset = perpDir * trailWave * trailInfluence * 0.6;
        trailOffset -= velDir * trailInfluence * 0.3; // slight backward drag
      }
      
      // Combine offsets
      vec2 uvOffset = (organicOffset + trailOffset) * influence;
      
      // Modulated UV for noise sampling (same texture pattern, position offset)
      vec2 modulatedUV = uv + uvOffset;
      vec2 modulatedSlowUV = slowUV + uvOffset * 0.5;
      
      // Recalculate curl (using modulated UV)
      float nm1 = snoise(modulatedUV + t * 0.1);
      float nm2 = snoise(modulatedUV * 1.5 + t * 0.08 + 100.0);
      float nm3 = snoise(modulatedUV * 0.5 - t * 0.05 + 200.0);
      
      vec2 modulatedCurl;
      modulatedCurl.x = nm2 - nm1;
      modulatedCurl.y = nm3 - nm2;
      modulatedCurl = normalize(modulatedCurl + 0.001) * length(vec2(nm1, nm2)) * 40.0;
      
      // Recalculate slowFlow (using modulated UV)
      vec2 modulatedSlowFlow = vec2(
        snoise(modulatedSlowUV + vec2(0.01, 0.0)) - snoise(modulatedSlowUV - vec2(0.01, 0.0)),
        snoise(modulatedSlowUV + vec2(0.0, 0.01)) - snoise(modulatedSlowUV - vec2(0.0, 0.01))
      ) * 50.0;
      
      // Combine effects - only use modulated textures
      vec2 totalDistort = modulatedCurl * 0.3 + modulatedSlowFlow * 0.4;
      
      // === ORGANIC SURFACE ===
      // Very slow surface undulation
      vec2 surfUV = px * 0.002 + t * 0.02;
      vec2 surfaceN;
      surfaceN.x = snoise(surfUV + vec2(0.01, 0.0)) - snoise(surfUV - vec2(0.01, 0.0));
      surfaceN.y = snoise(surfUV + vec2(0.0, 0.01)) - snoise(surfUV - vec2(0.0, 0.01));
      surfaceN *= 0.5;
      
      // Total normal
      vec2 normal = totalDistort * 0.006 + surfaceN;
      
      // === CHROMATIC REFRACTION ===
      float caStrength = 0.8 * (edgeFactor + u_hover * 0.5);
      
      // Smooth RGB shift based on distortion
      vec2 dir = normalize(normal + 0.001);
      float mag = length(normal);
      
      // Base color with subtle distortion tint
      vec3 base = u_baseColor;
      
      // === ORGANIC CHROMATIC DISPERSION ===
      float shift = mag * 0.4;
      vec3 color = base;
      // Organic RGB shift
      float flowR = snoise(dir * 2.0 + t * 0.2);
      float flowG = snoise(dir * 2.0 + t * 0.15 + 100.0);
      float flowB = snoise(dir * 2.0 + t * 0.25 + 200.0);
      color.r += flowR * shift * 0.6;
      color.g += flowG * shift * 0.25;
      color.b += flowB * shift * 1.1;
      
      // Organic purple tint
      float tintFlow = snoise(vec2(t * 0.1));
      color += vec3(0.03, 0.02, 0.05) * mag * caStrength * (0.8 + tintFlow * 0.4);
      
      // === ORGANIC EDGE HIGHLIGHT ===
      // Natural flowing edge glow
      float edgeGlow = edgeFactor * 0.7;
      float edgeFlow = snoise(vec2(atan(local.y, local.x) * 2.0, t * 0.3));
      vec3 edgeColor = vec3(0.52, 0.56, 0.76); // Soft blue
      edgeColor = mix(edgeColor, vec3(0.68, 0.52, 0.82), edgeFlow * 0.5 + 0.5); // Organic purple shift
      // Subtle organic shimmer
      float shimmer = snoise(vec2(edgeDist * 0.05, t * 0.5)) * 0.5 + 0.5;
      color = mix(color, edgeColor * 0.25 + base, edgeGlow * 0.2 * shimmer);
      
      // === ORGANIC FRESNEL ===
      vec3 viewDir = vec3(0.0, 0.0, 1.0);
      vec3 surfNorm = normalize(vec3(normal * 2.0, 1.0));
      float fresnel = pow(1.0 - abs(dot(viewDir, surfNorm)), 1.8);
      fresnel *= edgeFactor * 0.7;
      // Organic edge light variation
      float flowFresnel = snoise(vec2(t * 0.2)) * 0.3 + 0.7;
      color += vec3(0.76, 0.72, 0.90) * fresnel * 0.5 * flowFresnel;
      
      // === SOFT SPECULAR ===
      vec3 lightDir = normalize(vec3(0.3, 0.5, 1.0));
      vec3 halfV = normalize(lightDir + viewDir);
      float spec = pow(max(dot(surfNorm, halfV), 0.0), 56.0);
      spec *= (0.2 + u_hover * 0.35);
      color += vec3(0.90, 0.85, 0.98) * spec; // Brighter purple-white specular
      
      // === SUBTLE MOUSE PRESENCE ===
      float mDist = length(px - mousePos);
      
      // Very faint center highlight - like candlelight
      float coreRadius = 60.0;
      float coreGlow = smoothstep(coreRadius, 0.0, mDist) * u_hover * 0.5;
      
      // Soft outer glow
      float glowRadius = 140.0;
      float mGlow = smoothstep(glowRadius, coreRadius, mDist) * u_hover * 0.3;
      
      // Overall very faint
      float totalGlow = (coreGlow + mGlow) * 0.15;
      
      // Very faint blue-purple
      vec3 glowColor = vec3(0.18, 0.16, 0.24);
      color += glowColor * totalGlow;
      
      // === INNER GLOW ===
      float inner = smoothstep(60.0, 0.0, edgeDist) * 0.2;
      color += vec3(0.18, 0.15, 0.25) * inner; // Brighter purple inner glow
      
      // === SOFT VIGNETTE ===
      vec2 vigUV = local / halfSize;
      float vig = 1.0 - smoothstep(0.5, 1.0, length(vigUV));
      color *= 0.9 + vig * 0.1;
      
      // Subtle brightness adjustment
      color = clamp(color, 0.0, 1.0);
      
      fragColor = vec4(color, shapeAlpha * 0.95);
    }
  `;function e(e,t,n){const s=e.createShader(n);return e.shaderSource(s,t),e.compileShader(s),e.getShaderParameter(s,e.COMPILE_STATUS)?s:(e.deleteShader(s),null)}function o(t,n,s){const i=e(t,n,t.VERTEX_SHADER),a=e(t,s,t.FRAGMENT_SHADER);if(!i||!a)return null;const o=t.createProgram();return t.attachShader(o,i),t.attachShader(o,a),t.linkProgram(o),t.getProgramParameter(o,t.LINK_STATUS)?o:null}function t(e,t={}){const a=document.createElement("canvas");a.className="liquid-glass-canvas",a.style.cssText=`
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none; z-index: 0;
      border-radius: inherit; display: block;
    `,e.insertBefore(a,e.firstChild);const x=getComputedStyle(e);x.position==="static"&&(e.style.position="relative"),x.display==="inline"&&(e.style.display="block"),Array.from(e.children).forEach(e=>{e!==a&&!e.style.zIndex&&(e.style.cssText+="position: relative; z-index: 1;")});const i=a.getContext("webgl2",{alpha:!0,antialias:!0});if(!i)return null;const u=Math.min(window.devicePixelRatio,2);function d(){const t=e.getBoundingClientRect(),n=Math.max(1,Math.floor(t.width)),s=Math.max(1,Math.floor(t.height));(a.width!==n*u||a.height!==s*u)&&(a.width=n*u,a.height=s*u),i.viewport(0,0,a.width,a.height)}setTimeout(d,0),window.addEventListener("load",d);const c=o(i,n,s);if(!c)return null;const A=i.createBuffer();i.bindBuffer(i.ARRAY_BUFFER,A),i.bufferData(i.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),i.STATIC_DRAW),i.useProgram(c),i.enableVertexAttribArray(0),i.vertexAttribPointer(0,2,i.FLOAT,!1,0,0);const l={resolution:i.getUniformLocation(c,"u_resolution"),time:i.getUniformLocation(c,"u_time"),mouse:i.getUniformLocation(c,"u_mouse"),mouseVel:i.getUniformLocation(c,"u_mouseVel"),hover:i.getUniformLocation(c,"u_hover"),baseColor:i.getUniformLocation(c,"u_baseColor"),cornerRadius:i.getUniformLocation(c,"u_cornerRadius")},O={header:{baseColor:[.13,.14,.18],cornerRadius:36,responsive:!0},card:{baseColor:[.14,.15,.19],cornerRadius:36,responsive:!0},footer:{baseColor:[.12,.13,.17],cornerRadius:36,responsive:!0},"error-code":{baseColor:[.65,.45,.9],cornerRadius:40},button:{baseColor:[.25,.27,.35],cornerRadius:12},"error-button":{baseColor:[.65,.45,.9],cornerRadius:12},"hero-title":{baseColor:[.7,.5,.95],cornerRadius:20},"about-name":{baseColor:[.68,.48,.92],cornerRadius:16},"page-title":{baseColor:[.72,.52,.96],cornerRadius:18},"term-title":{baseColor:[.72,.52,.96],cornerRadius:20},moment:{baseColor:[.14,.15,.19],cornerRadius:36,responsive:!0}},g=O[t.preset]||O.card,p={...g,...t};function w(){if(p.responsive){const e=window.innerWidth<=767;p.cornerRadius=e?g.cornerRadius*.75:g.cornerRadius}}w();let r={x:.5,y:.5},h={x:.5,y:.5},f={x:.5,y:.5},m={x:0,y:0},v=0,b=0;const _=8,y=new Array(_).fill({x:.5,y:.5});function j(t,n=!1){const s=e.getBoundingClientRect(),o=n?t.touches[0].clientX:t.clientX,i=n?t.touches[0].clientY:t.clientY;h.x=(o-s.left)/s.width,h.y=1-(i-s.top)/s.height,b=1,e.setAttribute("data-hover","true")}function C(){b=0,e.setAttribute("data-hover","false")}e.addEventListener("mousemove",e=>j(e),{passive:!0}),e.addEventListener("mouseenter",e=>j(e),{passive:!0}),e.addEventListener("mouseleave",C),e.addEventListener("touchmove",e=>j(e,!0),{passive:!0}),e.addEventListener("touchend",C);let S=performance.now();function E(){const t=(performance.now()-S)*.001;f.x=r.x,f.y=r.y;const e=.12;r.x+=(h.x-r.x)*e,r.y+=(h.y-r.y)*e,m.x=(r.x-f.x)*10,m.y=(r.y-f.y)*10;for(let e=_-1;e>0;e--)y[e]={...y[e-1]};y[0]={x:r.x,y:r.y},v+=(b-v)*.08,i.useProgram(c),i.uniform2f(l.resolution,a.width,a.height),i.uniform1f(l.time,t),i.uniform2f(l.mouse,r.x,r.y),i.uniform2f(l.mouseVel,m.x,m.y),i.uniform1f(l.hover,v),i.uniform3fv(l.baseColor,p.baseColor),i.uniform1f(l.cornerRadius,p.cornerRadius*u),i.enable(i.BLEND),i.blendFunc(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA),i.drawArrays(i.TRIANGLES,0,6),requestAnimationFrame(E)}E(),window.addEventListener("resize",()=>{w(),d()});const k=new ResizeObserver(t=>{for(const n of t)n.target===e&&d()});return k.observe(e),{destroy:()=>{k.disconnect(),a.remove()},resize:d}}document.addEventListener("DOMContentLoaded",()=>{document.querySelectorAll("[data-liquid-glass]").forEach(e=>{t(e,{preset:e.dataset.liquidGlass||"card"})})}),window.LiquidGlass={init:t}})()