[{"title":"ICS_PA4 实验报告","url":"/2026/02/09/ics_pa4-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","date":"2026-02-09","content":"实验进度 我已完成 PA4 的所有必做内容（虚实交错的魔法、分时多任务），成功实现了分页机制、进程上下文切换，并能够让仙剑奇侠传和 Hello 程序同时在 Nanos-lite 上分时运行。\n必答题 分时多任务的具体过程 问题： 请结合代码, 解释分页机制和硬件中断是如何支撑仙剑奇侠传和hello程序在我们的计算机系统(Nanos-lite, AM, NEMU)中分时运行的。\nSolution:\n这一过程是时钟中断驱动与虚拟内存隔离共同作用的结果。我们可以将其拆解为以下几个关键步骤：\n初始准备与加载 在 init_proc() 中（nanos-lite/src/proc.c:34-60），Nanos-lite 加载了仙剑奇侠传、Hello、Menu 和 Nterm 四个程序。\n// pcb[0]: hello context_kload(\u0026amp;pcb[0], hello_fun, \u0026#34;hello\u0026#34;); // pcb[1]: 仙剑奇侠传 (PAL) char *argv_pal[] = {\u0026#34;/bin/pal\u0026#34;, \u0026#34;--skip\u0026#34;, NULL}; char *envp_pal[] = {\u0026#34;PATH=/bin\u0026#34;, NULL}; context_uload(\u0026amp;pcb[1], \u0026#34;/bin/pal\u0026#34;, argv_pal, envp_pal); 虚拟地址空间创建： context_uload 调用 protect()（am/src/riscv/nemu/vme.c:47-54），为每个进程分配独立的页目录表（Page Directory）并复制内核页表映射。 代码加载： Loader（nanos-lite/src/loader.c:49-100）将 ELF 文件加载到各自虚拟地址空间。通过 map() 函数建立虚拟地址到物理页帧的映射，确保不同进程的虚拟地址映射到不同的物理内存页。 中断触发 (The Trigger) 当仙剑奇侠传正在 CPU 上运行时，NEMU 的时钟设备定期产生中断信号（mcause = 0x80000007）。\n硬件响应： 硬件检测到中断，保存当前 PC 到 mepc，设置 mcause，并跳转到 __am_asm_trap（位于 am/src/riscv/nemu/trap.S:44）。 保存现场 (Context Saving) trap.S（am/src/riscv/nemu/trap.S:44-94）将仙剑奇侠传当前的通用寄存器、CSR 寄存器（包括 mstatus, mepc 等）压入当前进程的内核栈中，形成一个 Context 结构体。\n__am_asm_trap: csrrw sp, mscratch, sp # 交换sp和mscratch，从用户态切换到内核态 bnez sp, .from_user # 如果mscratch非零，说明来自用户态 ... .from_user: addi sp, sp, -CONTEXT_SIZE MAP(REGS, PUSH) # 保存所有通用寄存器 csrr t0, mscratch csrw mscratch, zero STORE t0, OFFSET_SP(sp) # 保存用户态sp 此时保存的上下文包含该进程的地址空间标识（RISC-V 中为 satp 寄存器，通过 __am_get_cur_as() 保存到 c-\u0026gt;pdir）。 进程调度 (Scheduling) 控制权传递给 C 代码 __am_irq_handle（am/src/riscv/nemu/cte.c:8-29），最终调用 schedule()（nanos-lite/src/proc.c:62-90）。\nContext* schedule(Context *prev) { if (current != NULL) { current-\u0026gt;cp = prev; // 保存当前上下文 } // 简单的轮转调度，支持前台进程权重 int weight = (current == \u0026amp;pcb[fg_pcb]) ? FG_WEIGHT : HELLO_WEIGHT; current_t++; if (current_t \u0026gt;= weight) { current_t = 0; if (current == \u0026amp;pcb[fg_pcb]) { current = \u0026amp;pcb[0]; // 切换到hello } else { current = \u0026amp;pcb[fg_pcb]; // 切换回前台进程 } } return current-\u0026gt;cp; } 上下文切换与地址空间切换 (The Switch) 这是最神奇的一步，发生在 __am_switch()（am/src/riscv/nemu/vme.c:63-71）。\nvoid __am_switch(Context *c) { if (vme_enable \u0026amp;\u0026amp; c-\u0026gt;pdir != NULL) { set_satp(c-\u0026gt;pdir); // 设置satp寄存器，切换页表 } } static inline void set_satp(void *pdir) { uintptr_t mode = 1ul \u0026lt;\u0026lt; (__riscv_xlen - 1); asm volatile(\u0026#34;csrw satp, %0\u0026#34; : : \u0026#34;r\u0026#34;(mode | ((uintptr_t)pdir \u0026gt;\u0026gt; 12))); } 栈切换： 栈指针 sp 被修改为 Hello 进程的上下文地址（在 trap.S 中通过 mv sp, a0 恢复）。 地址空间切换： 从 Hello 的上下文中恢复 pdir 到硬件的 MMU 基址寄存器 satp。 瞬间变化： 一旦 satp 改变，CPU 看到的“整个世界”（内存映射）瞬间变了。原本属于仙剑的虚拟地址 0x40000000 可能映射到物理页 X，而现在同样的虚拟地址 0x40000000 映射到了物理页 Y（Hello 的代码）。 恢复现场 (Restoration) trap.S（am/src/riscv/nemu/trap.S:78-94）执行 POP 操作，将 Hello 进程之前冻结的寄存器值恢复到 CPU 中，最后执行 mret。CPU 跳转到 Hello 程序的 PC 继续执行。\nLOAD t1, OFFSET_STATUS(sp) LOAD t2, OFFSET_EPC(sp) csrw mstatus, t1 csrw mepc, t2 LOAD t0, OFFSET_SP(sp) csrw mscratch, t0 # 恢复用户态sp到mscratch MAP(REGS, POP) # 恢复所有通用寄存器 addi sp, sp, CONTEXT_SIZE ... mret # 返回到用户态 总结： 分页机制保证了两个程序在内存中互不干扰（空间隔离），时钟中断保证了控制权能周期性地回到操作系统手中（时间共享），从而实现了“同时”运行的错觉。\n理解计算机系统 (段错误分析) 问题： 尝试在Linux中编写并运行以下程序:\nint main() { char *p = \u0026#34;abc\u0026#34;; p[0] = \u0026#39;A\u0026#39;; return 0; } 你会看到程序因为往只读字符串进行写入而触发了段错误。请你根据学习的知识和工具，从程序, 编译器, 链接器, 运行时环境, 操作系统和硬件等视角分析\u0026quot;字符串的写保护机制是如何实现的\u0026quot;。\nSolution: 段错误（Segmentation Fault）的发生是计算机系统各层级通力合作的结果，旨在保护内存安全。\n程序层 (C Language) 在 C 语言语义中，\u0026quot;abc\u0026quot; 是一个字符串字面量 (String Literal)。 根据 C 标准，修改字符串字面量的行为是 Undefined Behavior (UB)。 变量 p 只是一个指针，它指向了这个字面量的首地址。 编译器层 (Compiler - GCC) GCC 在编译源代码时，会将字符串字面量 \u0026quot;abc\u0026quot; 放置在特定的 Section 中。 通常，这个 Section 是 .rodata (Read-Only Data)。 我们可以通过 objdump -s 查看目标文件，发现 \u0026quot;abc\u0026quot; 确实位于 .rodata 段。 链接器层 (Linker - LD) 链接器将多个目标文件合并为可执行文件 (ELF)。 它会将所有的 .rodata section 合并到一个 Segment 中。 关键点： 链接器会将这个 Segment 标记为 Read-Only (R)。 工具验证： 使用 readelf -l test 可以看到对应的 LOAD Segment 的 Flg 只有 R (Read)，没有 W (Write)。 运行时环境/加载器层 (Loader - OS) 当 Linux 执行该程序时，Loader 读取 ELF Header。 Loader 请求内核分配物理内存，并建立虚拟内存映射。 关键动作： Loader 告知内核，这段包含 \u0026quot;abc\u0026quot; 的虚拟内存页，其权限必须严格设置为只读。 硬件层 (Hardware - MMU) 当程序执行到 p[0] = 'A' 时，CPU 发出一条 STORE 指令，试图向虚拟地址 p 写入数据。 MMU (Memory Management Unit) 拦截该请求，查询 TLB 或页表 (Page Table)。 MMU 发现该虚拟地址对应的 PTE (Page Table Entry) 中的权限位（Permission Bits）禁止写入 (Valid=1, Write=0)。 MMU 触发硬件异常（在 x86 上是 Page Fault，RISC-V 上是 Store Access Fault）。 操作系统层 (OS - Kernel) CPU 捕获异常，陷入内核态。 内核的 Page Fault Handler 检查出错原因。它发现这是一次合法的映射（地址有效），但是权限违规（试图写只读页）。 内核判定该进程非法操作，向该进程发送 SIGSEGV 信号。 进程收到信号，若无自定义处理，默认行为是 Core Dump 并终止运行。 结论： “写保护”是从 ELF 文件头部的标志位开始，一路传递到页表项的硬件权限位，最终由 MMU 硬件强制执行的铁律。\n思考题：操作系统与未来 关于 Fork 的思考 讲义中提到 Nanos-lite 难以实现 fork()。通过 PA4 的学习，我理解到 fork() 的核心在于地址空间的写时复制 (Copy-On-Write, COW)。\n如果直接完整复制父进程的物理内存给子进程，效率极低。现代 OS 通过将父子进程的页表项都设为“只读”，当任意一方尝试写入时，MMU 触发异常，OS 此时才分配新的物理页并复制数据。\n// COW 的简化流程示意： // 1. fork时，父子共享物理页，PTE都设为只读 map(parent_pgdir, va, pa, PTE_R); // 只读 map(child_pgdir, va, pa, PTE_R); // 同样映射，只读 // 2. 任一进程写入时触发Page Fault // 3. OS处理：分配新页、复制数据、更新页表为可写 void *new_pa = pgalloc(); memcpy(new_pa, pa, PGSIZE); map(pgdir, va, new_pa, PTE_R | PTE_W); // 现在可写 这在我的 Nanos-lite 中需要极强的内存管理模块支持，目前的实现还显得过于单薄。\n崩溃一致性 (Crash Consistency) 在做文件系统实验时，我意识到仅仅把数据 write 进 buffer 并不安全。如果此时断电，数据就丢了。真正的文件系统（如 ext4, NTFS）需要 Journaling (日志) 机制，先记录“我要修改数据”这件事，再修改数据。这样即使断电，重启后也能根据日志恢复现场，保证文件系统不损坏。这让我对 PA3 中简单的文件系统有了更深的敬畏。\n有趣的瞬间 成功运行分时多任务：仙剑与 Hello 并存 // proc.c 中的调度配置 #define FG_WEIGHT 100 // 前台进程权重（仙剑） #define HELLO_WEIGHT 1 // 后台进程权重（Hello） // 当仙剑运行时，每100个时间片才切换一次 // 当Hello运行时，每1个时间片就切换回仙剑 见证虚拟内存的魔法：同一个虚拟地址，不同的物理数据 在调试时，我观察到两个进程的页表（satp）指向不同的页目录，相同的虚拟地址 0x40000000（程序入口）却取到了不同的指令，这就是分页机制的威力。\n调试 trap.S 的艰辛 在实验过程中，我修复了 trap.S 中的 bug。问题出在用户态和内核态的栈切换逻辑：\n必须正确使用 mscratch 寄存器保存用户态栈指针 从用户态进入时要交换 sp 和 mscratch 恢复时要确保 mscratch 重新指向用户栈 csrrw sp, mscratch, sp # 进入时交换 ... csrrw sp, mscratch, sp # 退出时交换回来 实验心情 🤯 痛并快乐着。\nPA4 是整个 PA 系列中难度陡增的一章。从理解 satp 寄存器如何切换“世界”，到调试各种玄学的 Page Fault，过程非常痛苦😭。特别是处理上下文切换时，栈指针 sp 只要错一个字节，整个系统就会莫名其妙地跑飞。\n但当我在 Nanos-lite 上看到仙剑的画面流畅运行，而后台的 Hello 依然在顽强地输出字符时，那种对“并发”和“虚拟化”的理解瞬间具象化了。以前觉得高深莫测的概念，现在变成了我指尖的代码。\nI have truly created a world.\n","categories":["报告"],"tags":["ICS","PA"]},{"title":"ICS_PA3 实验报告","url":"/2025/12/12/ics_pa3-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","date":"2025-12-12","content":"实验进度 我已完成 PA3 的所有内容，并通过了所有的测试样例。\n必答题 理解上下文结构体的前世今生 问题： 你会在__am_irq_handle()中看到有一个上下文结构指针c, c指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? $ISA-nemu.h, trap.S, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?\nSolution:\nstruct Context { // TODO: fix the order of these members to match trap.S uintptr_t gpr[NR_REGS]; uintptr_t mcause; uintptr_t mstatus; uintptr_t mepc; void *pdir; }; 上下文结构 $c$ 的位置和来源 上下文结构 $c$ 指向的结构体实例保存在当前线程的内核栈上。 它是由 NEMU 的中断/异常处理汇编入口文件 trap.S 在中断/异常发生时，通过一系列汇编指令（主要是压栈操作）在栈上动态创建的。 上下文结构成员的赋值位置 所有成员的赋值都发生在 trap.S 文件中：\n2.1. 通用寄存器 (gpr[NR_REGS]) 赋值位置： trap.S。 赋值方式： 通过一系列 sw (store word) 或 sd (store doubleword) 指令（取决于 $32/64$ 位），将通用寄存器 $x1$ 到 $x31$（$x0$ 寄存器为 $0$，通常不需保存或以 $0$ 占位）的值依次压入栈中。 关键点： 这是保存现场的第一步，占用 $Context$ 结构体中最大的连续内存块。 2.2. 特权/系统寄存器 (mcause, mstatus, mepc) 这三个寄存器是 RISC-V 异常处理的核心，它们由硬件和软件协同赋值：\nmepc (Machine Exception Program Counter): 硬件赋值： 异常发生时，CPU 硬件将导致异常的指令地址（或紧随其后的指令地址）写入 $mepc$ 寄存器。 软件保存： 在 trap.S 中，通过 csrr (Control and Status Register Read) 指令将 $mepc$ 的值读出到临时通用寄存器，然后通过 sw/sd 指令存入栈中对应位置。 mstatus (Machine Status Register): 硬件赋值： 异常发生时，CPU 硬件更新 $mstatus$ 中的相关位（如设置 $MPP/MPIE$），以管理特权级和中断使能状态。 软件保存： 在 trap.S 中，通过 csrr 指令读出 $mstatus$ 的值，并存入栈中。 mcause (Machine Cause Register): 硬件赋值： 异常发生时，CPU 硬件将异常/中断的原因编号写入 $mcause$ 寄存器。 软件保存： 在 trap.S 中，通过 csrr 指令读出 $mcause$ 的值，并存入栈中。 2.3. 地址空间 (pdir) 赋值位置： trap.S。 赋值方式： $pdir$ 通常对应于 RISC-V 的 $SATP$ (Supervisor Address Translation and Protection) 寄存器，它保存着页表的基地址。在 trap.S 中，通过 csrr 指令读取 $SATP$ 的值，并将其存入栈中 $pdir$ 成员对应的位置。 注意： 讲义提到，MIPS32 和 RISC-V 可能将地址空间信息与 $0$ 号寄存器共用存储空间（即压入 $0$ 占位），但如果用于 $PA4$ 切换地址空间，则必须保存 $SATP$ 寄存器的真实值。 四部分内容的联系 ISA-nemu.h： 定义了上下文结构体的内存布局。 trap.S： 实现了根据该定义在栈上创建和填充上下文结构 $c$ 的具体动作（汇编）。 实现的新指令(自陷)： 是触发整个异常处理流程的源头。 上述讲义文字： 讲解了整个流程（异常处理、状态保存/恢复、上下文切换）的理论基础。 四者的联系是： 当新指令触发异常时，trap.S 依据 ISA-nemu.h 的定义创建 $c$，随后将 $c$ 传递给 C 语言处理函数，实现讲义中描述的异常处理功能。\n理解穿越时空的旅程 问题： 从yield test调用yield()开始, 到从yield()返回的期间, 这一趟旅程具体经历了什么? 软(AM, yield test)硬(NEMU)件是如何相互协助来完成这趟旅程的?\nSolution\n这趟“穿越时空的旅程”本质上是一次用户态陷入内核、保存上下文、调度切换、恢复上下文并返回的完整过程。它依赖于软件（AM 的异常处理例程）构建的数据结构和逻辑，以及硬件（NEMU）提供的异常响应机制。\n我们可以将整个旅程拆解为四个阶段。\n启程 旅程始于 yield-test 程序调用 AM 提供的 yield() 函数。\n软件行为 (yield()): 在 RISC-V 架构下，yield() 的核心是两条汇编指令：\n// abstract-machine/am/src/riscv/nemu/cte.c void yield() { asm volatile(\u0026#34;li a7, -1; ecall\u0026#34;); } li a7, -1: 将立即数 -1 写入 a7 寄存器。这是 AM 约定的“事件暗号”，用于告诉内核这是一个 yield 请求。 ecall: 执行环境调用指令，主动触发异常。 硬件行为 (NEMU isa_raise_intr): 当 NEMU 执行到 ecall 时，硬件电路（模拟器逻辑）被激活：\n设置异常号: 将 mcause 寄存器设置为 0xb (Environment call from M-mode)。 保存断点: 将当前的 PC 值（即 ecall 的地址）保存到 mepc 寄存器中。 跳转: 将 PC 设置为 mtvec 寄存器的值。在 cte_init 中，mtvec 已被初始化指向 __am_asm_trap。 上下文的保存 控制流跳转到了汇编入口 __am_asm_trap。此时，CPU 的状态（寄存器值）就是“现在的我”，我们需要把它冻结并保存下来。\nContext 结构体的前世今生： 在进入这段汇编之前，Context 只是一个 C 语言定义的结构体模板。而随着 __am_asm_trap 的执行，它在栈上被实体化了。\n# abstract-machine/am/src/riscv/nemu/trap.S __am_asm_trap: addi sp, sp, -CONTEXT_SIZE # 1. 在栈上开辟空间 # 2. 保存通用寄存器 (GPRs) # 使用宏 MAP(REGS, PUSH) 自动展开为一系列 STORE 指令 # 注意：REGS 宏中不包含 x0 和 x2(sp) MAP(REGS, PUSH) # 3. 保存 CSRs csrr t0, mcause csrr t1, mstatus csrr t2, mepc STORE t0, OFFSET_CAUSE(sp) STORE t1, OFFSET_STATUS(sp) STORE t2, OFFSET_EPC(sp) 这里的 MAP(REGS, PUSH) 宏会展开为一连串的 STORE 指令（sw 或 sd），将 CPU 里的通用寄存器一个个“搬运”到了内存堆栈中。此时，栈顶指针 sp 所指向的内存区域，就严格对应了 C 语言中的 Context 结构体。\n软件（汇编宏指令）利用硬件（STORE）将硬件状态（寄存器）写入了内存。至此，“现在的我”被封存为一个 Context 结构体\nC 语言核心处理 保存完毕后，汇编代码执行 mv a0, sp，将当前的栈顶地址（即刚才保存好的 Context 结构体的指针）作为参数，传递给 C 函数 jal __am_irq_handle。\n事件分发 (__am_irq_handle): // abstract-machine/am/src/riscv/nemu/cte.c Context* __am_irq_handle(Context *c) { if (user_handler) { Event ev = {0}; switch (c-\u0026gt;mcause) { case 0x0b: // 对应 ecall if (c-\u0026gt;GPR1 == -1) { // 检查 a7 是否为 -1 ev.event = EVENT_YIELD; } c-\u0026gt;mepc += 4; // 关键：将返回地址 +4，跳过 ecall 指令 break; ... } // 核心调度点 c = user_handler(ev, c); } return c; } 识别: 根据 c-\u0026gt;mcause (0xb) 和 c-\u0026gt;GPR1 (-1)，识别出这是 EVENT_YIELD。 修正: 执行 c-\u0026gt;mepc += 4。这是因为 mepc 存的是 ecall 的地址，如果不加 4，返回后会死循环执行 ecall。 调度: 调用 user_handler(ev, c)。 user_handler（在 yield-test 中是 simple_trap）接收了当前线程 A 的 Context 指针 c。 调度器可能会决定切换到线程 B。它会把线程 A 的 c 存起来，然后返回线程 B 的 Context 指针。 因此，__am_irq_handle 最后 return c 时，这个 c 已经指向了另一个线程的栈空间。 上下文恢复 C 函数返回后，回到了 __am_asm_trap 的后半部分。此时 a0 寄存器里装着目标线程的 Context 指针。\n栈切换 (mv a0, sp): 这是最关键的一行汇编。sp 被修改为目标线程的上下文地址。这意味着我们从线程 A 的栈“跳”到了线程 B 的栈。\n恢复硬件状态:\n# abstract-machine/am/src/riscv/nemu/trap.S __am_asm_trap: ... mv sp, a0 # 关键：切换栈指针到目标 Context # 1. 恢复 CSRs (主要是 mstatus 和 mepc) LOAD t1, OFFSET_STATUS(sp) LOAD t2, OFFSET_EPC(sp) csrw mstatus, t1 csrw mepc, t2 # 2. 恢复通用寄存器 # 使用宏 MAP(REGS, POP) 自动展开为一系列 LOAD 指令 MAP(REGS, POP) # 3. 释放栈空间 addi sp, sp, CONTEXT_SIZE # 4. 硬件返回 mret MAP(REGS, POP) 宏展开后的一系列 LOAD 指令将目标线程沉睡前保存的值重新装填进 CPU 寄存器。\n穿越完成 (mret): 最后执行 mret 指令。NEMU 硬件响应该指令：\n恢复 PC: 将 mepc 的值（目标线程被打断时的下一条指令地址）写入 PC。 特权级切换: 恢复机器模式状态。 当 mret 执行完毕，CPU 的 PC 指向了目标代码，所有的寄存器也变回了目标线程的样子。对于目标线程而言，感觉就像是从 yield() 函数里“返回”了一样（实际上是刚从上一次的 ecall 后面返回）。\nHello 程序是什么, 它从而何来, 要到哪里去 问题： 我们知道 navy-apps/tests/hello/hello.c 只是一个 C 源文件\u0026hellip; Hello 程序一开始在哪里? 它是怎么出现内存中的? 为什么会出现在目前的内存位置? 它的第一条指令在哪里? 究竟是怎么执行到它的第一条指令的? Hello 程序在不断地打印字符串, 每一个字符又是经历了什么才会最终出现在终端上?\nSolution:\n从代码到静态 ELF 编译与链接： 在 Navy-apps 环境下，通过交叉编译工具链，它被编译并链接成为 ELF (Executable and Linkable Format) 可执行文件。 Ramdisk： 在目前的 PA 阶段，我们还没有真正的硬盘驱动。编译生成的 hello ELF 文件实际上被打包进了 Nanos-lite 的镜像中，或者更具体地说，它位于 Ramdisk (内存模拟磁盘) 中。在 nanos-lite/src/resources.S 中，ramdisk.img 被包含在内核的代码段/数据段中。 此时，Hello 程序只是 Ramdisk 这一大块字节串中，偏移量为 0 (假设它是第一个文件) 的一段静止的二进制数据。 加载 加载过程 (loader)： 当 Nanos-lite 启动并决定运行 Hello 时，它调用 loader() 函数。loader 首先通过 ramdisk_read 读取 ELF Header，解析其中的 Program Header Table。 内存位置的确定： Loader 遍历 Program Header，寻找类型为 PT_LOAD 的段。它读取该段的 VirtAddr (虚拟内存地址) 和 Offset (文件偏移)。 为什么是这里？ 这个 VirtAddr (例如 MIPS/RISC-V 下通常是 0x83000000 附近) 并非随机选择，而是由 Navy-apps 编译时的 链接脚本 (LD script) 决定的。链接器约定了用户程序在内存中的位置，Loader 必须严格遵守这一约定，将代码和数据通过 ramdisk_read 拷贝到物理内存的对应位置。 对于 .bss 段（未初始化数据），Loader 还会根据 MemSiz 大于 FileSiz 的部分，将多出的内存空间清零。 跳转 第一条指令 (Entry Point)： ELF Header 中的 e_entry 字段记录了程序的入口地址。对于 Navy 程序，这个入口通常是 _start 函数（位于 crt0.S），它负责初始化 C 运行环境并调用 main。 伪造现场 (Context Creation)： Nanos-lite 并不会直接 jmp 到入口地址，而是采用了一种“欺骗”硬件的手段——构造中断上下文。 在 naive_uload 中，内核调用 new_context 创建一个陷阱上下文结构体 Context。最关键的一步是：将这个结构体中的 mepc (对于 RISC-V) 设置为 ELF 的入口地址 e_entry。 执行第一条指令： 内核随后调用 _switch 或直接从中断处理函数返回。代码执行流进入 trap.S 的恢复逻辑（参考上一题“穿越时空的旅程”），最终执行 mret 指令。 硬件响应 mret，将 PC 寄存器强行设置为 mepc 的值（即 Hello 的入口地址），并将特权级切换回用户模式。 此刻，Hello 程序加载成功，CPU 开始执行它的第一条指令。 执行 用户态 (Navy)： printf 进行字符串格式化后，最终调用到 libos/src/syscall.c 中的 _write 函数。 触发异常 (The Trap)： _write 将系统调用号 (SYS_write)、文件描述符 (stdout/1)、缓冲区地址和长度放入约定好的寄存器（如 RISC-V 的 a0-a7），然后执行自陷指令 ecall。 内核态 (Nanos-lite)： CPU 捕获异常，保存上下文，跳转到 __am_asm_trap，最终进入 do_syscall。 do_syscall 从上下文中读取系统调用号，识别出这是 SYS_write。 对于 fd == 1 (stdout) 的情况，内核调用 AM 提供的 putch 函数。 硬件层 (NEMU)： putch 实际上是向特定的 MMIO (内存映射 I/O) 地址（例如串口的数据寄存器地址）写入一个字节。 NEMU 的 vmem 模块监测到对该物理地址的写入操作，拦截该请求，并调用宿主机的 putchar，将字符打印在屏幕上。 仙剑奇侠传究竟如何运行 问题： 库函数, libos, Nanos-lite, AM, NEMU是如何相互协助, 来帮助仙剑奇侠传的代码从mgo.mkf文件中读出仙鹤的像素信息, 并且更新到屏幕上?\nSolution:\n整个过程是一次跨越计算机系统所有层次的接力跑。我们可以将仙鹤像素的旅程分为两个阶段：从文件到内存（读取阶段） 和 从内存到屏幕（显示阶段）。\n阶段一：从 mgo.mkf 到用户缓冲区 (读取) 应用层 (User App): 发起请求 在 PAL_SplashScreen() 函数中，代码调用了 PAL_MKFReadChunk(buf, ..., SPRITENUM_SPLASH_CRANE, gpGlobals-\u0026gt;f.fpMGO)。 这里的 fpMGO 是指向 mgo.mkf 的文件指针。 该函数内部会调用标准库函数 fseek 定位偏移量，然后调用 fread 请求读取数据。 库函数与 LibOS (libc \u0026amp; libos): 封装系统调用 fread 是 Newlib 提供的 C 标准库函数。它最终会调用底层系统调用接口 _read。 在 navy-apps/libs/libos/src/syscall.c 中，_read 将参数（系统调用号 SYS_read、文件描述符 fd、缓冲区地址 buf、长度 len）放入寄存器（如 RISC-V 的 a0-a7），并执行 自陷指令 (ecall)。\n操作系统 (Nanos-lite): 文件系统处理 CPU 响应自陷，切换到内核态，跳转到 nanos-lite 的异常处理入口 do_syscall。\n内核识别出 SYS_read，调用 fs_read。 fs_read 根据 fd 找到文件表中的 mgo.mkf，利用 ramdisk_read（因为目前文件系统基于 Ramdisk）从内存模拟的磁盘中，将仙鹤的压缩像素数据 拷贝 (memcpy) 到用户传入的缓冲区 buf 中。 读取完成后，内核通过 mret 返回用户态。 数据解压 (Computation) 回到应用层，PAL_SplashScreen 紧接着调用 Decompress(buf, lpSpriteCrane, ...)。这一步纯粹是 NEMU 执行通用指令，将压缩数据还原为原始像素数据，存放在 lpSpriteCrane 指向的内存中。 阶段二：从用户缓冲区到屏幕 (显示) 应用层 (User App): 准备画布 在循环中，程序计算仙鹤的坐标，调用 PAL_RLEBlitToSurface 将仙鹤的像素点画到一个软件模拟的 SDL_Surface（内存缓冲区）上。 最后，调用 VIDEO_UpdateScreen(NULL) 请求刷新屏幕。\n中间件 (NDL \u0026amp; MiniSDL): 抽象图形接口 VIDEO_UpdateScreen 属于 libminiSDL，它底层调用 NDL_DrawRect (Nanos-lite Display Library)。 NDL_DrawRect 将这一请求转化为对设备文件的写入操作：它打开（或复用）/dev/fb（帧缓冲设备），并调用 write。\n系统调用再次触发 (Trap) 类似于读取阶段，write 再次触发 ecall，陷入内核。这次的系统调用号是 SYS_write。\n操作系统 (Nanos-lite): 设备驱动 内核的 do_syscall 识别出 SYS_write。 fs_write 发现目标 fd 对应的是 /dev/fb，于是调用显示设备的写操作句柄（通常对应 events.c 或 device.c 中的 fb_write）。 fb_write 计算显存偏移量，最终调用 AM 提供的 IO 接口。\n抽象机器 (AM): 架构无关的 IO AM 执行 io_write(AM_GPU_FBDRAW, ...)。在 NEMU 的实现中，这通常意味着将像素数据通过 memcpy 拷贝到一段特定的物理内存区域（VMEM，显存），或者写入特定的 MMIO 寄存器以触发同步。\n硬件模拟 (NEMU): 最终呈现 当 AM 写入 VMEM 时，数据实际上写入了 NEMU 申请的数组中。 NEMU 的 vga_update_screen（或类似函数）在每一帧结束时被调用，它读取这段 VMEM 数组，利用宿主机的图形库（SDL），将这些像素点真正的“画”在宿主机的窗口上。\n总结： 仙鹤的像素数据，始于 ramdisk 的二进制流，经过 fs_read 的搬运进入用户内存，经由 CPU (Decompress) 的解压计算，再通过 NDL 和 fb_write 的层层封装，最终被写入显存，由 NEMU 的模拟硬件展示。这正是软件（Navy/Nanos-lite）、中间件（AM）与硬件（NEMU）紧密协作的结果。\n思考题 对比异常处理与函数调用 问题： 我们知道进行函数调用的时候也需要保存调用者的状态: 返回地址, 以及calling convention中需要调用者保存的寄存器. 而CTE在保存上下文的时候却要保存更多的信息. 尝试对比它们, 并思考两者保存信息不同是什么原因造成的\nSolution 两者保存信息的差异源于控制流转移的性质和目的不同。\n核心差异点 机制 函数调用 (Procedure Call) 异常/中断处理 (CTE) 控制流 协作式，基于软件约定。 非协作式，硬件或软件强制介入。 特权级 不切换。 必须切换（用户态 \\rightarrow 内核态）。 保存范围 部分通用寄存器（最小必需子集）。 全部通用寄存器（GPRs）+ 系统状态寄存器（CSRs）。 原因总结 非协作性： CTE 随时发生，内核无法预知哪些 GPRs 需要保留，因此必须保存所有 GPRs，以保证被中断程序无损恢复。函数调用是软件约定好的，只需保存约定子集。 特权级切换： CTE 涉及特权级提升，必须保存 CSRs（如 mstatus 和 mepc）来记录和恢复 CPU 的模式和状态。 目的不同： CTE 旨在创建完整的进程/线程快照（Context），这是操作系统实现进程调度和多任务的基础。 从加4操作看CISC和RISC 问题： 决定 EPC 是否加 4 的是硬件还是软件？CISC/RISC 方案的取舍？哪个更合理？\nSolution:\n决定 EPC 修正的责任是硬件复杂性与软件灵活性的权衡。\n方案 CISC (硬件处理) RISC (软件处理) 机制 硬件自动根据异常类型修正 EPC。 软件（内核）根据 mcause 手动修正 EPC。 取舍 优点： 异常处理延迟极低。 缺点： 硬件复杂度高，指令集（ISA）扩展性差。 优点： 硬件设计简单，ISA 统一精简，OS 灵活可控。 缺点： 异常处理延迟略高。 RISC 软件处理方案更合理。 理由： 它符合 RISC 哲学，将复杂性转移到低频发生的软件，从而简化 CPU 核心设计，提高 CPU 频率和效率。尽管异常延迟增加，但整体系统性能和可扩展性更高。\n如何识别不同格式的可执行文件? 问题： 如果你在GNU/Linux下执行一个从Windows拷过来的可执行文件, 将会报告\u0026quot;格式错误\u0026quot;. 思考一下, GNU/Linux是如何知道\u0026quot;格式错误\u0026quot;的?\nSolution\nGNU/Linux 内核通过 execve 系统调用尝试加载文件时，通过校验文件头部的**魔数（Magic Number）**来识别格式。\n内核操作： 当用户执行文件时，内核启动 execve，并读取文件开头的几个字节。 魔数校验： 内核依次检查注册的可执行文件格式处理器（binfmt）。 Linux 原生格式是 ELF，其魔数为 \\text{0x7FELF}。 Windows 文件是 PE 格式，其头部魔数与 ELF 不匹配。 识别失败： 所有已注册的 binfmt 处理器（包括 load_elf_binary）都无法识别文件头部的魔数，导致加载失败。 返回错误： 内核返回错误码 ENOEXEC（Exec format error）。Shell 将此翻译为用户可见的“格式错误”。 有趣的瞬间 实验心情 😊 感觉良好\n","categories":["报告"],"tags":["ICS","PA"]},{"title":"ICS_PA2 实验报告","url":"/2025/11/11/ics_pa2-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","date":"2025-11-11","content":"实验进度 我已完成 PA2 的所有内容，并通过了所有的测试样例。\n必答题 不停计算的机器 #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #define NREG 4 #define NMEM 16 // 定义指令格式 typedef union { struct { uint8_t rs : 2, rt : 2, op : 4; } rtype; struct { uint8_t addr : 4 , op : 4; } mtype; uint8_t inst; } inst_t; #define DECODE_R(inst) uint8_t rt = (inst).rtype.rt, rs = (inst).rtype.rs #define DECODE_M(inst) uint8_t addr = (inst).mtype.addr uint8_t pc = 0; // PC, C语言中没有4位的数据类型, 我们采用8位类型来表示 uint8_t R[NREG] = {}; // 寄存器 uint8_t M[NMEM] = { // 内存, 其中包含一个计算z = x + y的程序 0b11100110, // load 6# | R[0] \u0026lt;- M[y] 0b00000100, // mov r1, r0 | R[1] \u0026lt;- R[0] 0b11100101, // load 5# | R[0] \u0026lt;- M[x] 0b00010001, // add r0, r1 | R[0] \u0026lt;- R[0] + R[1] 0b11110111, // store 7# | M[z] \u0026lt;- R[0] 0b00010000, // x = 16 0b00100001, // y = 33 0b00000000, // z = 0 }; int halt = 0; // 结束标志 // 执行一条指令 void exec_once() { inst_t this; this.inst = M[pc]; // 取指 switch (this.rtype.op) { // 操作码译码 操作数译码 执行 case 0b0000: { DECODE_R(this); R[rt] = R[rs]; break; } case 0b0001: { DECODE_R(this); R[rt] += R[rs]; break; } case 0b1110: { DECODE_M(this); R[0] = M[addr]; break; } case 0b1111: { DECODE_M(this); M[addr] = R[0]; break; } default: printf(\u0026#34;Invalid instruction with opcode = %x, halting...\\n\u0026#34;, this.rtype.op); halt = 1; break; } pc ++; // 更新PC } int main() { while (1) { exec_once(); if (halt) break; } printf(\u0026#34;The result of 16 + 33 is %d\\n\u0026#34;, M[7]); return 0; } 问题： 画出在YEMU上执行的加法程序的状态机\nSolution:\n$$\\begin{aligned} \\text{State}_0 \u0026amp;: (PC=0, R[0]=0, R[1]=0, M[7]=0) \\ \u0026amp;\\downarrow \\text{ (load 6#: } R[0] \\leftarrow 33) \\ \\text{State}_1 \u0026amp;: (PC=1, R[0]=33, R[1]=0, M[7]=0) \\ \u0026amp;\\downarrow \\text{ (mov r1, r0: } R[1] \\leftarrow 33) \\ \\text{State}_2 \u0026amp;: (PC=2, R[0]=33, R[1]=33, M[7]=0) \\ \u0026amp;\\downarrow \\text{ (load 5#: } R[0] \\leftarrow 16) \\ \\text{State}_3 \u0026amp;: (PC=3, R[0]=16, R[1]=33, M[7]=0) \\ \u0026amp;\\downarrow \\text{ (add r0, r1: } R[0] \\leftarrow 16+33=49) \\ \\text{State}_4 \u0026amp;: (PC=4, R[0]=49, R[1]=33, M[7]=0) \\ \u0026amp;\\downarrow \\text{ (store 7#: } M[7] \\leftarrow 49) \\ \\text{State}_5 \u0026amp;: (PC=5, R[0]=49, R[1]=33, M[7]=49) \\ \\end{aligned}$$\n问题： 通过RTFSC理解YEMU如何执行一条指令\nSolution:\nYEMU的指令执行周期（在 exec_once() 函数中）遵循经典的冯·诺依曼周期：取指 (Fetch) -\u0026gt; 译码 (Decode) -\u0026gt; 执行 (Execute) -\u0026gt; 更新PC (Update PC)。\n** 1. 取指 (Fetch)**\ninst_t this; this.inst = M[pc]; // 取指 指令存储在内存 M 中。 程序计数器 pc 给出下一条要执行的指令的地址。 M[pc] 的内容（一个 $\\text{uint8_t}$ 值）被取出并存储在 this 联合体中。 ** 2. 译码 (Decode) 和 执行 (Execute)**\n指令的译码和执行是通过 switch (this.rtype.op) 结构完成的，它首先通过 inst_t 联合体的 rtype 结构体字段 op 提取操作码 (Opcode)。\nOpcode (this.rtype.op) 指令类型 译码宏 (Operands) 执行操作 (Execution) 汇编指令 含义 $\\text{0b0000}$ (0) R-type DECODE_R ($r_t, r_s$) $R[r_t] = R[r_s]$ mov rt, rs 寄存器间传输 $\\text{0b0001}$ (1) R-type DECODE_R ($r_t, r_s$) $R[r_t] += R[r_s]$ add rt, rs 寄存器加法 $\\text{0b1110}$ (14) M-type DECODE_M ($addr$) $R[0] = M[addr]$ load addr\\# 从内存加载到 $R[0]$ $\\text{0b1111}$ (15) M-type DECODE_M ($addr$) $M[addr] = R[0]$ store addr\\# 从 $R[0]$ 存储到内存 R-type 指令 (mov, add): 使用 $r_type$ 结构体的 $r_t$ (目标寄存器) 和 $r_s$ (源寄存器) 字段来操作寄存器 $R[]$ 中的值。 M-type 指令 (load, store): 使用 $m_type$ 结构体的 $addr$ (内存地址) 字段来操作内存 $M[]$ 和寄存器 $R[0]$ (隐含目标/源)。 ** 3. 错误处理 (Invalid Opcode)**\ndefault: printf(\u0026#34;Invalid instruction with opcode = %x, halting...\\n\u0026#34;, this.rtype.op); halt = 1; break; 如果取出的指令的操作码不匹配任何已定义的指令（0, 1, 14, 15），则设置 halt = 1 标志并打印错误信息，从而导致程序停止运行。 ** 4. 更新PC (Update PC)**\npc ++; // 更新PC 无论是成功执行了一条指令，还是遇到了无效指令并设置了 halt 标志，程序计数器 pc 都会简单地递增 1，指向内存中的下一个字节。 RTFSC(2) 问题： 请整理一条指令在NEMU中的执行过程\nSolution 指令执行流程\n1. 启动执行 (cpu_exec)\ncpu_exec(uint64_t n): 这是 CPU 模拟的入口函数，接收要执行的指令数量 $n$。\nvoid cpu_exec(uint64_t n) { g_print_step = (n \u0026lt; MAX_INST_TO_PRINT); // ITRAC/si 命令的条件 switch (nemu_state.state) { case NEMU_END: case NEMU_ABORT: case NEMU_QUIT: /* ... 状态检查 ... */ return; default: nemu_state.state = NEMU_RUNNING; // 设置运行状态 } uint64_t timer_start = get_time(); // 记录起始时间 execute(n); // **进入执行循环** uint64_t timer_end = get_time(); g_timer += timer_end - timer_start; // 更新耗时 /* ... 结束状态处理和统计 ... */ } 2. 执行循环 (execute)\nexecute(uint64_t n): 循环 $n$ 次，在每次迭代中执行一条指令。\nstatic void execute(uint64_t n) { Decode s; for (;n \u0026gt; 0; n --) { exec_once(\u0026amp;s, cpu.pc); // 执行单条指令 g_nr_guest_inst ++; // 指令计数更新 trace_and_difftest(\u0026amp;s, cpu.pc); // 追踪、对比、检查监视点 if (nemu_state.state != NEMU_RUNNING) break; // 检查状态，若暂停/结束则退出循环 IFDEF(CONFIG_DEVICE, device_update()); // 设备更新 } } 3. 单步执行 (exec_once)\n这是执行一条指令的核心步骤：\n步骤 函数/宏 描述 对应的代码片段 (exec_once) I. 设置 PC s-\u0026gt;pc = pc; 将当前的 程序计数器 (PC) 存入 Decode 结构体 $s$ 中。 s-\u0026gt;pc = pc; II. 指令解码与执行 isa_exec_once(s); ISA 相关操作。 负责取指、解码、执行指令，并计算出下一条指令的地址 (Next PC, s-\u0026gt;dnpc)。 isa_exec_once(s); III. 更新 PC cpu.pc = s-\u0026gt;dnpc; 将 CPU 的全局 PC 更新为执行结果计算出的 下一条指令地址 (s-\u0026gt;dnpc)。 cpu.pc = s-\u0026gt;dnpc; IV. FTRACE CONFIG_FTRACE, ftrace_log(...) 函数调用追踪：记录函数调用和返回信息。 #ifdef CONFIG_FTRACE ... ftrace_log(...) ... #endif V. ITRACE/IRINGBUF CONFIG_ITRACE, push_iringbuf(...) 指令追踪：格式化指令信息（机器码、汇编）并存入日志缓冲区 s-\u0026gt;logbuf，然后推入环形缓冲区。 #ifdef CONFIG_ITRACE ... disassemble(...) ... push_iringbuf(...) ... #endif 4. 追踪与检查 (trace_and_difftest)\n在 exec_once 之后，execute 函数调用 trace_and_difftest：\nstatic void trace_and_difftest(Decode *_this, vaddr_t dnpc) { #ifdef CONFIG_ITRACE_COND // CONFIG_ITRACE_COND 配置的追踪条件 if (ITRACE_COND) { log_write(\u0026#34;%s\\n\u0026#34;, _this-\u0026gt;logbuf); } #endif if (g_print_step) { IFDEF(CONFIG_ITRACE, puts(_this-\u0026gt;logbuf)); } // MAX_INST_TO_PRINT 控制的单步输出 IFDEF(CONFIG_DIFFTEST, difftest_step(_this-\u0026gt;pc, dnpc)); // **双机对比** #ifdef CONFIG_WATCHPOINT // **监视点检查** check_watchpoints(); if (nemu_state.state == NEMU_STOP) { printf(\u0026#34;Watchpoint triggered!\\n\u0026#34;); } #endif } 5. 状态更新\n指令计数更新: g_nr_guest_inst ++; 状态检查: if (nemu_state.state != NEMU_RUNNING) break; 设备更新 (DEVICE): IFDEF(CONFIG_DEVICE, device_update()); 6. 结束统计\n执行循环结束后，cpu_exec 函数继续执行，并根据最终的 nemu_state.state 决定后续动作，最终调用 statistic() 打印统计数据：\n// cpu_exec // ... switch (nemu_state.state) { case NEMU_RUNNING: nemu_state.state = NEMU_STOP; break; // 执行完毕 n 条指令后，设为 NEMU_STOP case NEMU_END: case NEMU_ABORT: Log(\u0026#34;nemu: %s at pc = \u0026#34; FMT_WORD, /* ... */); // fall through case NEMU_QUIT: statistic(); // 遇到 END/ABORT/QUIT 则打印统计数据 } 关键数据结构\nCPU_state cpu: 全局变量，存储 CPU 寄存器状态和 pc。\nCPU_state cpu = {}; Decode s: 局部变量，用于存储单条指令的执行上下文。\nDecode s; // 在 execute 函数内局部声明 程序如何运行 问题： 请你以打字小游戏为例, 结合\u0026quot;程序在计算机上运行\u0026quot;的两个视角, 来剖析打字小游戏究竟是如何在计算机上运行的. 具体地, 当你按下一个字母并命中的时候, 整个计算机系统(NEMU, ISA, AM, 运行时环境, 程序) 是如何协同工作, 从而让打字小游戏实现出\u0026quot;命中\u0026quot;的游戏效果?\nSolution 微观视角(程序) 1. 程序结构和逻辑\n打字小游戏的核心是事件驱动和帧同步的循环：\n数据结构: struct character chars[NCHAR] 存储了屏幕上每个下落字母的状态（字符、位置 x, y、速度 v、状态计时 t）。 游戏主循环 (main): 通过 io_read(AM_TIMER_UPTIME).us 获取当前时间，计算出应该渲染的帧数 (frames)，实现帧同步。 更新逻辑 (game_logic_update): 在 current \u0026lt; frames 的循环中，模拟字母下落、生成新字母、判断输入字母是否正确等游戏逻辑。 输入处理 (io_read(AM_INPUT_KEYBRD)): 循环读取键盘事件，并调用 check_hit 函数处理按键。 渲染 (render): 当有新的逻辑更新时 (current \u0026gt; rendered)，调用 render 将新的游戏状态绘制到屏幕。 2. “命中”事件的程序逻辑\n当按下键盘上一个字母（如 \u0026lsquo;A\u0026rsquo;）时：\n读取输入:\n// main 函数中的输入处理 AM_INPUT_KEYBRD_T ev = io_read(AM_INPUT_KEYBRD); if (ev.keydown \u0026amp;\u0026amp; lut[ev.keycode]) { check_hit(lut[ev.keycode]); // 调用命中检测 } 程序通过 io_read(AM_INPUT_KEYBRD) 接口从抽象的输入设备获取按键事件 (ev)。如果是一个有效的按下事件 (ev.keydown)，则将原始键码 (ev.keycode) 通过查找表 lut 转换为字符，并传递给 check_hit。\n命中检测和更新状态 (check_hit):\nvoid check_hit(char ch) { // 遍历所有字母，找到与按键匹配且正在下落的**最靠下**的字母 // ... 找到命中的字母索引 m if (m == -1) { wrong++; // 未命中 } else { hit++; chars[m].v = -(screen_h - CHAR_H + 1) / (FPS); // 关键：速度设为负值，使其向上飞出 } } 程序遍历 chars 数组，寻找字符 c-\u0026gt;ch 与按键 ch 相同，并且速度 c-\u0026gt;v \u0026gt; 0（即正在下落）的字母。 为了符合“打中最快要掉落的”的游戏规则，它找到的是最靠下 (c-\u0026gt;y 最大) 的那个。 命中效果实现: 将被击中字母的速度 chars[m].v 设置为一个负值，使其开始向上飞出。 渲染命中效果 (render):\n// render 函数中决定绘制颜色 int col = (c-\u0026gt;v \u0026gt; 0) ? WHITE : (c-\u0026gt;v \u0026lt; 0 ? GREEN : RED); io_write(AM_GPU_FBDRAW, c-\u0026gt;x, c-\u0026gt;y, texture[col][c-\u0026gt;ch - \u0026#39;A\u0026#39;], CHAR_W, CHAR_H, false); 在下一个渲染周期，由于被命中的字母 c 的速度 c-\u0026gt;v \u0026lt; 0，render 函数会为其选择 GREEN 颜色，并使用 io_write(AM_GPU_FBDRAW) 将其绘制到屏幕上，从而实现了“字母变绿向上飞出”的命中视觉效果。\n宏观视角\n1. 抽象中间层 (AM)\nAM (Abstract Machine) 提供了与底层硬件抽象接口，是连接上层程序和底层硬件/模拟器的桥梁。\n输入抽象:\nAM_INPUT_KEYBRD 是对键盘硬件的抽象。 当程序调用 io_read(AM_INPUT_KEYBRD) 时，AM 会负责与键盘设备交互，获取按键的键码和状态（按下/松开），并以统一的 AM_INPUT_KEYBRD_T 结构体形式返回给程序。 图形抽象:\nAM_GPU_FBDRAW 是对显卡帧缓冲区 (Framebuffer) 的抽象。 当程序调用 io_write(AM_GPU_FBDRAW, ...) 时，AM 会负责将像素数据写入显卡的内存区域，驱动显示更新。 2. 指令集架构 (ISA)\n无论是程序逻辑 (check_hit 中的比较和赋值) 还是 AM 接口的调用，最终都编译成目标 ISA（如 RISC-V）的机器指令。\n例如，在 check_hit 中将速度设置为负数的 C 代码： chars[m].v = -(screen_h - CHAR_H + 1) / (FPS); 将被编译器翻译成一系列的 ISA 指令（如加载、减法、除法、取反、存储等），通过这些指令这些指令操作寄存器和内存。 3. 执行环境 (NEMU)\nNEMU (NJU EMUlator) 是一个指令集模拟器，它负责模拟一个真实 CPU 的行为，执行上述 ISA 指令。\n执行程序逻辑: NEMU 逐条取指、译码、执行，完成 check_hit 内部的逻辑判断和数据修改（如修改 chars[m].v 的内存值）。 模拟 I/O 交互 (I/O Mapped Memory / Memory Mapped I/O): 当程序执行到涉及 io_read 或 io_write 的指令时，它实际上是在访问一个特定的内存地址（即设备寄存器）。 读取输入: 当 NEMU 发现 CPU 试图读取键盘设备寄存器时（通过 AM 抽象），NEMU 会暂停模拟，查询主机操作系统的键盘事件，并根据事件状态伪造一个设备返回值（AM_INPUT_KEYBRD_T），模拟键盘数据准备就绪。 渲染输出: 当 NEMU 发现 CPU 试图写入帧缓冲区地址时（通过 io_write(AM_GPU_FBDRAW, ...)），NEMU 会将该数据转发到主机操作系统的图形界面上，实现屏幕像素的更新。 编译与链接 问题： 分别尝试去掉static, 去掉inline或去掉两者, 然后重新进行编译,请分别解释为什么这些错误会发生/不发生?\n#ifndef __CPU_IFETCH_H__ #include \u0026lt;memory/vaddr.h\u0026gt; static inline uint32_t inst_fetch(vaddr_t *pc, int len) { uint32_t inst = vaddr_ifetch(*pc, len); (*pc) += len; return inst; } #endif Solution 单独去掉 static (保留 inline)\n结果： 不报错 (链接器处理)。 原因： inline 函数在头文件中定义且为外部链接。现代链接器（如 GNU ld）会将多个目标文件中生成的函数定义视为弱符号，并自动选择其中一个作为最终的外部定义，避免了多重定义错误。 单独去掉 inline (保留 static)\n结果： 不报错 (内部链接)。 原因： static 将函数的链接性限制为内部链接。每个包含该头文件的 .c 文件都会拥有一个该函数的私有副本，互相隔离，链接器看不到冲突的符号。 同时去掉两者\n结果： 链接错误。 原因： 函数成为一个普通的外部链接函数。由于头文件被多个源文件包含，链接器会在最终的可执行文件中发现多个目标文件都定义了同名的强符号，违反了 C 语言的单一定义原则（One Definition Rule, ODR），导致 multiple definition 链接错误。 问题：\n1.在nemu/inclu/common.h中添加一行volatile static int dummy; 然后重新编译NEMU. 请问重新编译后的NEMU含有多少个dummy变量的实体? 你是如何得到这个结果的? 2.添加上题中的代码后, 再在nemu/include/debug.h中添加一行volatile static int dummy; 然后重新编译NEMU. 请问此时的NEMU含有多少个dummy变量的实体? 与上题中dummy变量实体数目进行比较, 并解释本题的结果. 3.修改添加的代码, 为两处dummy变量进行初始化:volatile static int dummy = 0; 然后重新编译NEMU. 你发现了什么问题? 为什么之前没有出现这样的问题? (回答完本题后可以删除添加的代码.) Solution\n1.添加代码并编译后，在nemu目录下终端输入nm -a build/riscv32-nemu-interpreter | grep dummy -c返回36 2.重复上问步骤，依旧返回36 volatile static int dummy;未初始化的缘故，dummy是暂定定义。在单个 .c 文件中，即使通过包含多个头文件看到多次相同的定义，编译器也会将它们合并为一个实体。所以依旧含有36个dummy变量的实体 3.添加代码后编译出现错误 octopus@ICS:~/Projects/ics2025/nemu$ make + CC src/nemu-main.c In file included from /home/octopus/Projects/ics2025/nemu/include/utils.h:19, from /home/octopus/Projects/ics2025/nemu/include/debug.h:21, from /home/octopus/Projects/ics2025/nemu/include/common.h:47, from src/nemu-main.c:16: /home/octopus/Projects/ics2025/nemu/include/common.h:57:21: error: redefinition of ‘dummy’ 57 | volatile static int dummy = 0; | ^~~~~ In file included from /home/octopus/Projects/ics2025/nemu/include/debug.h:19, from /home/octopus/Projects/ics2025/nemu/include/common.h:47, from src/nemu-main.c:16: /home/octopus/Projects/ics2025/nemu/include/common.h:57:21: note: previous definition of ‘dummy’ was here 57 | volatile static int dummy = 0; | ^~~~~ In file included from /home/octopus/Projects/ics2025/nemu/include/common.h:47, from src/nemu-main.c:16: /home/octopus/Projects/ics2025/nemu/include/debug.h:44:21: error: redefinition of ‘dummy’ 44 | volatile static int dummy = 0; | ^~~~~ In file included from /home/octopus/Projects/ics2025/nemu/include/utils.h:19, from /home/octopus/Projects/ics2025/nemu/include/debug.h:21, from /home/octopus/Projects/ics2025/nemu/include/common.h:47, from src/nemu-main.c:16: /home/octopus/Projects/ics2025/nemu/include/common.h:57:21: note: previous definition of ‘dummy’ was here 57 | volatile static int dummy = 0; | ^~~~~ In file included from src/nemu-main.c:16: /home/octopus/Projects/ics2025/nemu/include/common.h:57:21: error: redefinition of ‘dummy’ 57 | volatile static int dummy = 0; | ^~~~~ In file included from /home/octopus/Projects/ics2025/nemu/include/common.h:47, from src/nemu-main.c:16: /home/octopus/Projects/ics2025/nemu/include/debug.h:44:21: note: previous definition of ‘dummy’ was here 44 | volatile static int dummy = 0; | ^~~~~ make: *** [/home/octopus/Projects/ics2025/nemu/scripts/build.mk:34: /home/octopus/Projects/ics2025/nemu/build/obj-riscv32-nemu-interpreter/src/nemu-main.o] Error 1 octopus@ICS:~/Projects/ics2025/nemu$ 未初始化时不报错，而现在初始化后报错，根本原因在于变量的定义方式：\n未初始化时（volatile static int dummy;）：\ndummy为暂定定义,即没有存储类说明符和初始化方法的任何外部数据声明。 在同一个编译单元（单个 .c 文件经过预处理后）内，可以出现同一个变量的多个暂定定义，编译器会将它们合并成一个变量实体。因此，重复包含头文件不会报错。 初始化后（volatile static int dummy = 0;）：\n对全局变量进行初始化（例如 = 0）的行为，在 C 语言中构成一个强定义。 C 语言规范要求，在单个编译单元（即单个 .c 文件）中，不允许对同一个变量进行多次强定义。 这违反了“单一定义原则”，因此编译器立即报错 redefinition of 'dummy'。 了解Makefile 问题： 请描述你在am-kernels/kernels/hello/目录下敲入make ARCH=$ISA-nemu 后, make程序如何组织.c和.h文件, 最终生成可执行文件am-kernels/kernels/hello/build/hello-$ISA-nemu.elf. (这个问题包括两个方面:Makefile的工作方式和编译链接的过程.) 关于Makefile工作方式的提示:\nMakefile中使用了变量, 包含文件等特性 Makefile运用并重写了一些implicit rules 在man make中搜索-n选项, 也许会对你有帮助 RTFM Solution\n1.Makefile 的工作方式 在 am-kernels/kernels/hello/ 目录下执行 make ARCH=$ISA-nemu 后，make 程序会按照以下步骤组织和执行：\n目标与变量确定 加载本地 Makefile：首先加载 am-kernels/kernels/hello/Makefile。 变量设置：NAME = hello, SRCS = hello.c。 包含通用 Makefile：通过 include $(AM_HOME)/Makefile 包含 AbstractMachine 的通用 Makefile。通用 Makefile 中的规则和变量开始生效。 确定目标：由于命令行没有指定目标 (MAKECMDGOALS 为空)，根据通用 Makefile 中的设置，默认目标为 image (MAKECMDGOALS = image, .DEFAULT_GOAL = image)。 环境检查和变量解析： 通过 ARCH_SPLIT 和 word 函数，从 ARCH=$ISA-nemu 中解析出 ISA (riscv32) 和 PLATFORM (nemu)。 确定路径：DST_DIR 被设置为 am-kernels/kernels/hello/build/$ARCH-nemu。 确定最终文件：IMAGE 变量确定最终可执行文件的路径前缀，最终的 ELF 文件目标是 $(IMAGE).elf，即 am-kernels/kernels/hello/build/hello-$ISA-nemu.elf。 确定链接文件：OBJS 变量被设置为 $(DST_DIR)/hello.o。LIBS 变量包含 am 和 klib。LINKAGE 初始为 $(OBJS)。 导入架构特定配置：通过 -include $(AM_HOME)/scripts/$(ARCH).mk 导入特定于 $ISA-nemu 的配置，例如编译器、链接脚本 (LDSCRIPTS) 和额外的编译/链接标志。 依赖递归与展开 链接依赖的展开：由于目标是 image，Makefile 不会执行 archive 目标。 LIB_TEMPLATE 宏会为每个库 (am, klib) 生成一个依赖规则，目标是库的归档文件 (如 $(AM_HOME)/am/build/am-$ARCH.a)。 这些库的归档文件被添加到 LINKAGE 中。 递归调用：当需要构建这些库归档文件时，make 会递归调用自身，进入库的目录 ($(AM_HOME)/am 或 $(AM_HOME)/klib)，并以 archive 为目标执行 make (@$(MAKE) -s -C $(AM_HOME)/$(1) archive)。 构建顺序：image -\u0026gt; image-dep -\u0026gt; $(IMAGE).elf。 2. C文件的编译链接过程 生成 am-kernels/kernels/hello/build/hello-$ISA-nemu.elf 文件主要经过以下三个阶段：\n1. 编译 目标：将源代码文件 hello.c 编译成目标文件 $(DST_DIR)/hello.o (即 am-kernels/kernels/hello/build/$ISA-nemu/hello.o)。 规则：使用通用 Makefile 中重写的编译规则： $(DST_DIR)/%.o: %.c @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + CC $\u0026lt; @$(CC) -std=gnu11 $(CFLAGS) -c -o $@ $(realpath $\u0026lt;) 执行命令：make 会执行类似如下的命令： gcc -std=gnu11 -O2 -MMD -Wall -Werror [各种 -I\u0026lt;path\u0026gt; 头文件路径] [各种 -D\u0026lt;macro\u0026gt; 宏定义] -fno-builtin ... -c -o build/$ISA-nemu/hello.o hello.c $(CC)：使用交叉编译器（例如 mips64-linux-gnu-gcc 或 riscv64-unknown-elf-gcc，取决于 ARCH）。 $(CFLAGS)：包含了优化选项 (-O2)、警告/错误选项 (-Wall -Werror)、头文件路径 (-I) 和重要的宏定义 (-D__ISA__ 等)；此外还有嵌入式/裸机编程常用的选项 (-fno-builtin, -fno-stack-protector)。 -MMD：该选项指示编译器生成一个 .d 文件 (build/$ISA-nemu/hello.d)，其中包含目标文件 hello.o 对所有依赖头文件的信息。这个 .d 文件会被 -include 导入到 Makefile 中，从而实现头文件修改时，.o 文件也能被正确地重新编译。 2. 归档 目标：将 AbstractMachine 内核和库（am 和 klib）的源代码编译生成各自的静态库文件 (e.g., $(AM_HOME)/am/build/am-$ARCH.a)。 规则：通过递归调用 make archive 在各个库的目录下完成。 3. 链接 目标：将所有目标文件 (hello.o) 和所有依赖的库文件 (am-$ARCH.a, klib-$ARCH.a) 链接起来，生成最终的 ELF 可执行文件 $(IMAGE).elf。 规则：使用链接规则： $(IMAGE).elf: $(LINKAGE) $(LDSCRIPTS) # ... @$(LD) $(LDFLAGS) -o $@ --start-group $(LINKAGE) --end-group 执行命令：make 会执行类似如下的命令： ld -z noexecstack -T \u0026lt;link_script\u0026gt; -o build/hello-$ISA-nemu.elf --start-group \\ build/$ISA-nemu/hello.o \\ /path/to/am/build/am-$ISA-nemu.a \\ /path/to/klib/build/klib-$ISA-nemu.a \\ --end-group $(LD)：使用交叉链接器。 $(LDFLAGS)：包含 LDSCRIPTS 变量指定的链接脚本 (-T)。它定义了代码段、数据段在内存中的布局、入口点等信息。 $(LINKAGE)：包含所有 .o 文件和 .a 库文件。 --start-group ... --end-group：确保库文件之间如果存在相互依赖，链接器也能正确解析所有符号。 至此，am-kernels/kernels/hello/build/hello-$ISA-nemu.elf 可执行文件生成完成。\n思考题 RISC-V 提供了专门的指令来高效地加载 32 位常数：\nLUI (Load Upper Immediate): 加载高 20 位立即数。 ADDI (Add Immediate): 加载低 12 位立即数（并进行符号扩展）。 测试返回： 有趣的瞬间 实验心情 😊 感觉良好\n","categories":["报告"],"tags":["ICS","PA"]},{"title":"ICS_PA1 实验报告","url":"/2025/09/24/ics_pa1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","date":"2025-09-24","content":"实验进度 我已完成 PA1 的所有内容，并通过了所有的测试样例。\n必答题 程序是个状态机 问题： 画出计算 1+2+\u0026hellip;+100 的程序的状态机。\nSolution:\n// PC: instruction | // label: statement 0: mov r1, 0 | pc0: r1 = 0; 1: mov r2, 0 | pc1: r2 = 0; 2: addi r2, r2 , 1 | pc2: r2 = r2 + 1; 3: add r1, r1 , r2 | pc3: r1 = r1 + r2; 4: cmp r2 100 | pc4: compare r2 with 100; 5: jl 2 | pc5: if r2 \u0026lt; 100, jump to pc2 程序的状态机如下：\n//(PC,r1,r2) (0,x,x)→(1,0,x)→ (2,0,0)→(3,0,1)→(4,1,1)→(5,1,1)→ (2,1,1)→(3,1,2)→(4,3,2)→(5,3,2)→ ... (2,4851,98)→(3,4851,99)→(4,4950,99)→(5,4950,99)→ (2,4950,99)→(3,4950,100)→(4,5050,100)→end 理解基础设施 问题： 通过计算来体会简易调试器的作用。\n假设条件：\n需要编译 500 次 NEMU 才能完成 PA。 500 次编译中，有 90% 的次数用于调试。 没有实现简易调试器时，只能通过 GDB 调试，每次获取并分析一个信息需要 30 秒。 需要获取并分析 20 个信息才能排除一个 bug。 通过简易调试器只需要花费 10 秒的时间获取并分析相同的信息。 解答： （1）没有简易调试器的情况：\n用于调试的编译次数：500×90 次 每次调试总时间：20 个信息×30 秒/信息=600 秒 总调试时间：450 次×600 秒/次=270,000 秒 总调试时间（小时）：270,000÷3600=75 小时 如果没有简易调试器，将在调试上花费 75 小时。 （2）使用简易调试器的情况：\n每次调试总时间：20 个信息×10 秒/信息=200 秒 总调试时间：450 次×200 秒/次=90,000 秒 总调试时间（小时）：90,000÷3600=25 小时 节省的时间：75−25=50 小时 使用简易调试器可以节省 50 小时 的调试时间。 总结： 实现简易调试器在本学期中可节省约 50 小时 的调试时间。\nRTFM：理解科学查阅手册的方法 问题： 在 RISC-V ISA 手册中查阅以下问题所在的位置，并将需要阅读的范围写到实验报告中。 （1）riscv32 有哪几种指令格式？\n手册位置： 《The RISC-V Instruction Set Manual Volume I》第 15 页，2.2 Base Instruction Formats。 解答： RISC-V 有四种基本的指令格式： R-Type I-Type S-Type U-Type （2）LUI 指令的行为是什么？\n手册位置： 《The RISC-V Instruction Set Manual Volume I》第 19 页，2.4 Integer Computational Instructions。 解答： LUI (Load Upper Immediate) 指令将一个 20 位的立即数加载到目标寄存器的高 20 位，同时将低 12 位清零。 （3）mstatus 寄存器的结构是怎么样的？\n手册位置： 《The RISC-V Instruction Set Manual Volume II》第 20 页，3.1.6 Machine Status Registers (mstatus and mstatush)。 解答： mstatus 寄存器是机器模式下的状态寄存器，包含中断使能位、特权模式信息等关键控制位。 Shell 命令统计代码行数 问题分析 我们需要统计 NEMU 项目中 PA1 完成后的代码行数，并与 PA0 基准进行比较，计算新增代码量。\n统计方法与结果 （1）PA1 完成后代码总行数（含空行）\n# 执行命令 find -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; | xargs wc -l 结果：267,533 行 （2）PA1 期间新增代码行数\n# 切换到 PA0 分支获取基准数据 git checkout pa0 find -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; | xargs wc -l PA0 基准： 266,809 行 PA1 完成： 267,533 行 新增代码量： 267,533−266,809=724 行 （3）排除空行的有效代码统计\n# 排除空行统计命令 find -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; | xargs grep -v \u0026#39;^$\u0026#39; | wc -l PA0 有效代码： 230,501 行 PA1 有效代码： 231,191 行 新增有效代码： 231,191−230,501=690 行 （4）Makefile 自动化配置 在 nemu/scripts/build.mk 文件中添加以下内容实现自动化统计：\ncount: @find -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; | xargs wc -l count-no-blank: @find -name \u0026#34;*.c\u0026#34; -o -name \u0026#34;*.h\u0026#34; | xargs grep -v \u0026#39;^$\u0026#39; | wc -l 使用方式：\nmake count # 统计总行数（含空行） make count-no-blank # 统计有效代码行数 总结表格 统计类型 PA0 基准 PA1 完成 新增量 总行数（含空行） 266,809 267,533 +724 有效代码行数 230,501 231,191 +690 编译选项解释 问题： 解释 nemu/scripts/build.mk 文件中的 -Wall 和 -Werror 编译选项。\nCFLAGS := -O2 -MMD -Wall -Werror $(INCLUDES) $(CFLAGS) RTFM: Warning Options (Using the GNU Compiler Collection (GCC)) （1）-Wall 选项\n-Wall # Warning all(not really) 作用： 开启 GCC 编译器的所有标准警告信息，帮助开发者发现代码中的潜在问题。 包含的警告： 未使用的变量、可疑的类型转换、可能的空指针解引用等常见问题。 优点： 在编译阶段提前发现许多常见的编程错误，提高代码质量。 （2）-Werror 选项\n-Werror # Turn all warnings into errors. 作用： 将编译过程中产生的所有警告都作为错误处理，导致编译失败。 效果： 强制开发者必须解决所有警告，不能忽略任何潜在问题。 优点： 确保代码库中不存在任何编译警告，提高代码的严谨性和可维护性。 为什么需要使用 -Wall 和 -Werror？ 通过强制处理所有警告，确保了代码的高质量。这有助于避免潜在的逻辑错误和运行时问题，从而降低未来的维护成本。\n遇到的问题 \u0026amp; 看法以及趣事😊 神秘的➗0: 在写表达式测试程序 gen-expr.c 有这么一道思考题： STFM有：\nThe ISO International Standard of the C Programming Language, draft N1570 \u0026ldquo;6.5.5 Multiplicative operators\u0026rdquo;:\n5 The result of the / operator is the quotient from the division of the first operand by the second; the result of the % operator is the remainder. In both operations, if the value of the second operand is zero, the behavior is undefined.\nN1570 3. Terms, definitions, and symbols:\n3.4.3.\n1 undefined behavior\nbehavior, upon use of a nonportable or erroneous program construct or of erroneous data, for which this International Standard imposes no requirements\n2 NOTE Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).\n在C语言标准中，除零操作（如 \\0 整型除法）被明确定义为未定义行为。当程序执行此类未定义行为时，其结果将是不可预测的，且编译器不提供任何保证。在编译阶段，编译器通常会发出警告：\nwarning: division by zero is undefined [-Wdivision-by-zero] 运行编译后的程序通常会触发以下错误：\nFloating point exception (core dumped) 基于这一错误特征，我首先想到可以利用程序框架提供的 pclose() 函数来检测除零异常。具体实现如下：\nfp = popen(\u0026#34;/tmp/.expr\u0026#34;, \u0026#34;r\u0026#34;); assert(fp != NULL); int pclose_ret = pclose(fp); if (pclose_ret != 0) { i--; continue; // 若运行失败，跳过当前迭代 } pclose() 函数在关闭管道的同时，会返回所执行命令的退出状态：\n当程序正常运行时，pclose() 返回值为 0 当出现除零等异常行为时，pclose() 返回值将不为 0 通过检查 pclose_ret 的值是否为 0，即可有效判断目标程序中是否发生了除零异常。理论上，这个问题应该到此解决了。然而在测试中出现了意想不到的麻烦：\n在将 gen-expr.c 生成的表达式作为输入测试 NEMU 表达式运算时，触发了 expr() 中的除零检测，导致测试中断。检查发现生成的表达式确实包含了除零操作。但令人困惑的是，同样的表达式在 C 程序中进行计算时却能得出结果，并没有触发上文提及的除零报错。STFW发现，除零行为在某些情况下,编译器会对常量表达式进行优化，直接忽略掉除0的部分 这说明通过pclose()的返回值我们并不能百分百排除生成除0的表达式。重新研究编译器对除0行为反馈的信息：出现除0行为时编译会有警告！我想到可以在修改程序框架的编译命令以实现将所有warning都视为error：\nint ret = system(\u0026#34;gcc /tmp/.code.c -Werror -o /tmp/.expr\u0026#34;); if (ret != 0) { i--; continue; } 终于解决了gen-expr.c的除0判断问题。\n运算符的结合性与无符号运算： 在编写 expr.c 的过程中，我最初忽略了单目运算符与双目运算符在结合性上的重要差异。由于没有相应调整主运算符的更新规则，仅进行了简单的功能性测试，当基础表达式计算正常时，我便以为大功告成。 然而，在提交至 OJ 平台进行线上测试时，测试结果显示复杂表达式运算出现错误。花费了大半天时间排查，却始终未能定位到问题所在。直到完成并修复了表达式测试工具 gen-expr.c ，通过测试才发现错误与单目运算符相关。回想起之前的提示，我终于意识到单目运算符的结合性与双目运算符不同，随即修复了这一问题。 解决了结合性问题后，继续使用 gen-expr.c 进行测试，发现仍有计算错误。经过仔细检查，发现原来是我对无符号运算的理解存在偏差——错误地将 eval() 函数的返回值类型定义为 unsigned int，导致每次递归返回值均为无符号整型，从而引发了非预期的数值溢出，最终造成计算结果与真实值不符。 这次经历让我深刻体会到：在编程中绝不能偷懒，否则潜在的 Bug 终会在某一天找上门来。\n思考题 使用函数调用在 init_monitor() 中的主要好处包括：\n模块化：将初始化过程分解为独立的函数，每个函数负责一个特定任务，使代码结构更清晰。 可读性：函数名能直观描述每个步骤的作用，比直接展开代码更易于理解。 可维护性：如果某个初始化步骤需要修改，只需调整相应函数，避免影响其他代码。 可重用性：这些函数可能在程序其他部分被重复使用，减少代码冗余。 cpu_exec()声明如下：\nvoid cpu_exec(uint64_t n) { //... 参数类型和转换： cpu_exec 函数接受 uint64_t（无符号 64 位整型）参数。 $-1$ 的实际值： 传入的带符号 -1 会被转换为 uint64_t 的最大值，即 $2^{64}-1$（0xFFFFFFFFFFFFFFFF）。 执行时间： 函数将被要求执行 $2^{64}-1$ 条指令。在实际环境中，这等价于**“无限执行”**，直到程序遇到 NEMU_END、NEMU_ABORT 或 NEMU_QUIT 等停止条件。 C99/C11 标准明确定义了有符号数到无符号数的转换规则，并非未定义行为。 C语言标准库的 I/O 缓冲机制，对 标准输出流 (stdout) 默认采用的行缓冲模式。当 printf() 输出 换行符 (\\n) 时，缓冲区会被自动刷新 (flush)，输出立即显示到终端上。防止输出延迟，同时提高了可读性。\n为什么要使用无符号类型？\n良定义行为： 无符号数溢出是良定义行为（环绕到 $0$），而有符号数溢出是 C 语言的未定义行为（UB），会导致程序行为不可预测。 右移一致性： 无符号数右移总是逻辑右移（左侧补 $0$），行为一致；而有符号数右移是实现定义的（可能是算术右移），行为不确定。 表示地址/位模式： 内存地址、大小、位掩码等本质上都是非负数，无符号类型能更准确地表示这些概念。 如果进行有符号运算，可能发生什么问题？\n程序奔溃/错误结果： 有符号溢出（UB）可能导致程序崩溃或生成不可靠的错误数据。 位操作错误： 算术右移会保留符号位，干扰底层位操作（如掩码和提取）的预期结果。 混合运算陷阱： 负数在与无符号数混合运算时会被提升为一个巨大的正数，导致错误的比较和判断。 static 在此处的含义: static 限制了变量的可见范围（链接性），使其成为内部链接。该变量（如 wp_pool）仅能在其定义的源文件（编译单元）内部被访问和使用，对其他文件不可见。且具有静态存储期，程序整个运行期间都存在，只初始化一次。\n使用 static 的主要目的是实现封装和模块化：\n信息隐藏：将 wp_pool 变量“私有化”给它所在的源文件使用，外部文件不能直接访问或意外修改，从而避免了意外的副作用。 避免命名冲突：防止在大型项目中，其他源文件定义了同名的全局变量或函数，导致链接错误。 实验心情 😊 感觉良好 复习了一些C语言的知识，锻炼了STFW与STFM的能力😊 希望后面能继续认真完成PA\n","categories":["报告"],"tags":["ICS","PA"]}]