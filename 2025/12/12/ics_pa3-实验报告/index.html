<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>DIMS|ICS_PA3 实验报告</title><meta name=description content="🐙"><meta name=author content="OCTOPUS"><meta property="og:url" content="https://octopusdims.github.io/2025/12/12/ics_pa3-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"><meta property="og:site_name" content="DIMS"><meta property="og:title" content="ICS_PA3 实验报告"><meta property="og:description" content="实验进度 我已完成 PA3 的所有内容，并通过了所有的测试样例。
必答题 理解上下文结构体的前世今生 问题： 你会在__am_irq_handle()中看到有一个上下文结构指针c, c指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? $ISA-nemu.h, trap.S, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?
Solution:
struct Context { // TODO: fix the order of these members to match trap.S uintptr_t gpr[NR_REGS]; uintptr_t mcause; uintptr_t mstatus; uintptr_t mepc; void *pdir; }; 上下文结构 $c$ 的位置和来源 上下文结构 $c$ 指向的结构体实例保存在当前线程的内核栈上。 它是由 NEMU 的中断/异常处理汇编入口文件 trap.S 在中断/异常发生时，通过一系列汇编指令（主要是压栈操作）在栈上动态创建的。 上下文结构成员的赋值位置 所有成员的赋值都发生在 trap.S 文件中：
2.1. 通用寄存器 (gpr[NR_REGS]) 赋值位置： trap.S。 赋值方式： 通过一系列 sw (store word) 或 sd (store doubleword) 指令（取决于 $32/64$ 位），将通用寄存器 $x1$ 到 $x31$（$x0$ 寄存器为 $0$，通常不需保存或以 $0$ 占位）的值依次压入栈中。 关键点： 这是保存现场的第一步，占用 $Context$ 结构体中最大的连续内存块。 2.2. 特权/系统寄存器 (mcause, mstatus, mepc) 这三个寄存器是 RISC-V 异常处理的核心，它们由硬件和软件协同赋值："><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-12T13:16:23+00:00"><meta property="article:modified_time" content="2025-12-12T13:16:23+00:00"><meta property="article:tag" content="ICS"><meta property="article:tag" content="PA"><meta name=twitter:card content="summary"><meta name=twitter:title content="ICS_PA3 实验报告"><meta name=twitter:description content="实验进度 我已完成 PA3 的所有内容，并通过了所有的测试样例。
必答题 理解上下文结构体的前世今生 问题： 你会在__am_irq_handle()中看到有一个上下文结构指针c, c指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? $ISA-nemu.h, trap.S, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?
Solution:
struct Context { // TODO: fix the order of these members to match trap.S uintptr_t gpr[NR_REGS]; uintptr_t mcause; uintptr_t mstatus; uintptr_t mepc; void *pdir; }; 上下文结构 $c$ 的位置和来源 上下文结构 $c$ 指向的结构体实例保存在当前线程的内核栈上。 它是由 NEMU 的中断/异常处理汇编入口文件 trap.S 在中断/异常发生时，通过一系列汇编指令（主要是压栈操作）在栈上动态创建的。 上下文结构成员的赋值位置 所有成员的赋值都发生在 trap.S 文件中：
2.1. 通用寄存器 (gpr[NR_REGS]) 赋值位置： trap.S。 赋值方式： 通过一系列 sw (store word) 或 sd (store doubleword) 指令（取决于 $32/64$ 位），将通用寄存器 $x1$ 到 $x31$（$x0$ 寄存器为 $0$，通常不需保存或以 $0$ 占位）的值依次压入栈中。 关键点： 这是保存现场的第一步，占用 $Context$ 结构体中最大的连续内存块。 2.2. 特权/系统寄存器 (mcause, mstatus, mepc) 这三个寄存器是 RISC-V 异常处理的核心，它们由硬件和软件协同赋值："><script>(function(){document.documentElement.classList.add("dark"),localStorage.theme="dark"})()</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Noto+Serif+SC:wght@400;600;700&display=swap" rel=stylesheet><link rel=icon type=image/webp href=/images/favicon.webp><link rel=stylesheet href=/css/index.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script></head><body class=is-post><div class=floating-shapes><span class=shape style=--delay:0s;--x:15%;--y:25%>✦</span>
<span class=shape style=--delay:1.2s;--x:85%;--y:15%>○</span>
<span class=shape style=--delay:2.5s;--x:75%;--y:65%>✦</span>
<span class=shape style=--delay:0.8s;--x:10%;--y:55%>○</span>
<span class=shape style=--delay:1.8s;--x:90%;--y:45%>✦</span>
<span class=shape style=--delay:3s;--x:25%;--y:80%>○</span></div><header class=header data-glass-nav data-liquid-glass=header><div class=header-inner><a href=/ class=logo><span class=logo-text>DIMS</span></a><nav class=nav><a href=/archives class=nav-link>归档
</a><a href=/gallery class=nav-link>相册
</a><a href=/moments class=nav-link>日志
</a><a href=/about class=nav-link>关于</a></nav><div class=header-actions><button class="icon-btn search-toggle" aria-label=Search>
<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg></button></div></div></header><div class=search-modal id=searchModal><div class=search-container><div class=search-box><input type=text class=search-input id=searchInput placeholder=搜索文章... autocomplete=off>
<button class="icon-btn search-close" id=searchClose aria-label="Close search">
<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class=search-results id=searchResults></div><div class=search-footer><span class=search-hint>按 <kbd>ESC</kbd> 关闭</span>
<span class=search-hint><kbd>↑</kbd> <kbd>↓</kbd> 选择</span>
<span class=search-hint><kbd>Enter</kbd> 打开</span></div></div></div><main class=main><div class="layout layout-full"><section class="content content-full"><article class=post><div class=container><header class=post-header><h1 class=post-title>ICS_PA3 实验报告</h1><div class=post-meta><time class=post-date datetime=2025-12-12T13:16:23Z>2025年12月12日</time>
<span class=post-categories><a href=/categories/%E6%8A%A5%E5%91%8A/ class=category-link>报告</a>
</span><span class=post-wordcount>1163 字</span></div></header><div class=post-body><aside class=post-toc><div class=toc-header><span class=toc-title>目录</span></div><div class=toc-content><nav id=TableOfContents><ul><li><a href=#实验进度>实验进度</a></li><li><a href=#必答题>必答题</a><ul><li><a href=#理解上下文结构体的前世今生>理解上下文结构体的前世今生</a></li><li><a href=#理解穿越时空的旅程>理解穿越时空的旅程</a></li><li><a href=#hello-程序是什么-它从而何来-要到哪里去>Hello 程序是什么, 它从而何来, 要到哪里去</a></li><li><a href=#仙剑奇侠传究竟如何运行>仙剑奇侠传究竟如何运行</a></li></ul></li><li><a href=#思考题>思考题</a><ul><li><a href=#对比异常处理与函数调用>对比异常处理与函数调用</a></li><li><a href=#从加4操作看cisc和risc>从加4操作看CISC和RISC</a></li><li><a href=#如何识别不同格式的可执行文件>如何识别不同格式的可执行文件?</a></li></ul></li><li><a href=#有趣的瞬间>有趣的瞬间</a></li><li><a href=#实验心情>实验心情</a></li></ul></nav></div></aside><div class=post-content><h2 id=实验进度>实验进度</h2><p>我已完成 PA3 的<strong>所有内容</strong>，并通过了<strong>所有的测试样例</strong>。</p><hr><h2 id=必答题>必答题</h2><h3 id=理解上下文结构体的前世今生>理解上下文结构体的前世今生</h3><p><strong>问题：</strong> 你会在<code>__am_irq_handle()</code>中看到有一个上下文结构指针<code>c</code>, <code>c</code>指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? <code>$ISA-nemu.h</code>, <code>trap.S</code>, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?</p><p><strong>Solution:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>Context</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// TODO: fix the order of these members to match trap.S
</span></span></span><span class=line><span class=cl>  <span class=kt>uintptr_t</span> <span class=n>gpr</span><span class=p>[</span><span class=n>NR_REGS</span><span class=p>];</span> 
</span></span><span class=line><span class=cl>  <span class=kt>uintptr_t</span> <span class=n>mcause</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uintptr_t</span> <span class=n>mstatus</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uintptr_t</span> <span class=n>mepc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>pdir</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><hr><h4 id=上下文结构-c-的位置和来源>上下文结构 $c$ 的位置和来源</h4><ol><li>上下文结构 $c$ 指向的结构体实例保存在<strong>当前线程的内核栈上</strong>。</li><li>它是由 NEMU 的中断/异常处理汇编入口文件 <strong><code>trap.S</code></strong> 在中断/异常发生时，通过一系列汇编指令（主要是压栈操作）在栈上动态创建的。</li></ol><hr><h4 id=上下文结构成员的赋值位置>上下文结构成员的赋值位置</h4><p>所有成员的赋值都发生在 <strong><code>trap.S</code></strong> 文件中：</p><h5 id=21-通用寄存器-gprnr_regs>2.1. 通用寄存器 (<code>gpr[NR_REGS]</code>)</h5><ul><li><strong>赋值位置：</strong> <code>trap.S</code>。</li><li><strong>赋值方式：</strong> 通过一系列 <code>sw</code> (store word) 或 <code>sd</code> (store doubleword) 指令（取决于 $32/64$ 位），将通用寄存器 $x1$ 到 $x31$（$x0$ 寄存器为 $0$，通常不需保存或以 $0$ 占位）的值依次压入栈中。</li><li><strong>关键点：</strong> 这是保存现场的第一步，占用 $Context$ 结构体中最大的连续内存块。</li></ul><h5 id=22-特权系统寄存器-mcause-mstatus-mepc>2.2. 特权/系统寄存器 (<code>mcause</code>, <code>mstatus</code>, <code>mepc</code>)</h5><p>这三个寄存器是 RISC-V 异常处理的核心，它们由硬件和软件协同赋值：</p><ul><li><strong><code>mepc</code> (Machine Exception Program Counter):</strong><ul><li><strong>硬件赋值：</strong> 异常发生时，CPU 硬件将导致异常的指令地址（或紧随其后的指令地址）写入 $mepc$ 寄存器。</li><li><strong>软件保存：</strong> 在 <code>trap.S</code> 中，通过 <code>csrr</code> (Control and Status Register Read) 指令将 $mepc$ 的值读出到临时通用寄存器，然后通过 <code>sw</code>/<code>sd</code> 指令存入栈中对应位置。</li></ul></li><li><strong><code>mstatus</code> (Machine Status Register):</strong><ul><li><strong>硬件赋值：</strong> 异常发生时，CPU 硬件更新 $mstatus$ 中的相关位（如设置 $MPP/MPIE$），以管理特权级和中断使能状态。</li><li><strong>软件保存：</strong> 在 <code>trap.S</code> 中，通过 <code>csrr</code> 指令读出 $mstatus$ 的值，并存入栈中。</li></ul></li><li><strong><code>mcause</code> (Machine Cause Register):</strong><ul><li><strong>硬件赋值：</strong> 异常发生时，CPU 硬件将异常/中断的原因编号写入 $mcause$ 寄存器。</li><li><strong>软件保存：</strong> 在 <code>trap.S</code> 中，通过 <code>csrr</code> 指令读出 $mcause$ 的值，并存入栈中。</li></ul></li></ul><h5 id=23-地址空间-pdir>2.3. 地址空间 (<code>pdir</code>)</h5><ul><li><strong>赋值位置：</strong> <code>trap.S</code>。</li><li><strong>赋值方式：</strong> $pdir$ 通常对应于 RISC-V 的 <strong>$SATP$</strong> (Supervisor Address Translation and Protection) 寄存器，它保存着页表的基地址。在 <code>trap.S</code> 中，通过 <code>csrr</code> 指令读取 $SATP$ 的值，并将其存入栈中 $pdir$ 成员对应的位置。</li><li><strong>注意：</strong> 讲义提到，MIPS32 和 RISC-V 可能将地址空间信息与 $0$ 号寄存器共用存储空间（即压入 $0$ 占位），但如果用于 $PA4$ 切换地址空间，则必须保存 $SATP$ 寄存器的真实值。</li></ul><hr><h4 id=四部分内容的联系>四部分内容的联系</h4><ol><li><strong><code>ISA-nemu.h</code>：</strong> 定义了上下文结构体的<strong>内存布局</strong>。</li><li><strong><code>trap.S</code>：</strong> 实现了根据该定义在栈上<strong>创建和填充</strong>上下文结构 $c$ 的具体动作（汇编）。</li><li><strong>实现的新指令(自陷)：</strong> 是<strong>触发</strong>整个异常处理流程的源头。</li><li><strong>上述讲义文字：</strong> 讲解了整个流程（异常处理、状态保存/恢复、上下文切换）的<strong>理论基础</strong>。</li></ol><p><strong>四者的联系是：</strong> 当新指令触发异常时，<code>trap.S</code> 依据 <code>ISA-nemu.h</code> 的定义创建 $c$，随后将 $c$ 传递给 C 语言处理函数，实现讲义中描述的异常处理功能。</p><h3 id=理解穿越时空的旅程>理解穿越时空的旅程</h3><p><strong>问题：</strong> 从yield test调用yield()开始, 到从yield()返回的期间, 这一趟旅程具体经历了什么? 软(AM, yield test)硬(NEMU)件是如何相互协助来完成这趟旅程的?</p><p><strong>Solution</strong></p><p>这趟“穿越时空的旅程”本质上是一次<strong>用户态陷入内核、保存上下文、调度切换、恢复上下文并返回</strong>的完整过程。它依赖于软件（AM 的异常处理例程）构建的数据结构和逻辑，以及硬件（NEMU）提供的异常响应机制。</p><p>我们可以将整个旅程拆解为四个阶段。</p><h4 id=启程>启程</h4><p>旅程始于 <code>yield-test</code> 程序调用 AM 提供的 <code>yield()</code> 函数。</p><ul><li><p><strong>软件行为 (<code>yield()</code>):</strong>
在 RISC-V 架构下，<code>yield()</code> 的核心是两条汇编指令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// abstract-machine/am/src/riscv/nemu/cte.c
</span></span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>yield</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>asm</span> <span class=k>volatile</span><span class=p>(</span><span class=s>&#34;li a7, -1; ecall&#34;</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol><li><code>li a7, -1</code>: 将立即数 -1 写入 <code>a7</code> 寄存器。这是 AM 约定的“事件暗号”，用于告诉内核这是一个 <code>yield</code> 请求。</li><li><code>ecall</code>: 执行环境调用指令，主动触发异常。</li></ol></li><li><p><strong>硬件行为 (NEMU <code>isa_raise_intr</code>):</strong>
当 NEMU 执行到 <code>ecall</code> 时，硬件电路（模拟器逻辑）被激活：</p><ol><li><strong>设置异常号</strong>: 将 <code>mcause</code> 寄存器设置为 <code>0xb</code> (Environment call from M-mode)。</li><li><strong>保存断点</strong>: 将当前的 PC 值（即 <code>ecall</code> 的地址）保存到 <code>mepc</code> 寄存器中。</li><li><strong>跳转</strong>: 将 PC 设置为 <code>mtvec</code> 寄存器的值。在 <code>cte_init</code> 中，<code>mtvec</code> 已被初始化指向 <code>__am_asm_trap</code>。</li></ol></li></ul><h4 id=上下文的保存>上下文的保存</h4><p>控制流跳转到了汇编入口 <code>__am_asm_trap</code>。此时，CPU 的状态（寄存器值）就是“现在的我”，我们需要把它冻结并保存下来。</p><ul><li><p><strong>Context 结构体的前世今生：</strong>
在进入这段汇编之前，<code>Context</code> 只是一个 C 语言定义的结构体模板。而随着 <code>__am_asm_trap</code> 的执行，它在栈上被实体化了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=c1># abstract-machine/am/src/riscv/nemu/trap.S
</span></span></span><span class=line><span class=cl><span class=nl>__am_asm_trap:</span>
</span></span><span class=line><span class=cl>    <span class=nf>addi</span> <span class=no>sp</span><span class=p>,</span> <span class=no>sp</span><span class=p>,</span> <span class=p>-</span><span class=no>CONTEXT_SIZE</span>  <span class=c1># 1. 在栈上开辟空间
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 2. 保存通用寄存器 (GPRs)
</span></span></span><span class=line><span class=cl>    <span class=c1># 使用宏 MAP(REGS, PUSH) 自动展开为一系列 STORE 指令
</span></span></span><span class=line><span class=cl>    <span class=c1># 注意：REGS 宏中不包含 x0 和 x2(sp)
</span></span></span><span class=line><span class=cl>    <span class=nf>MAP</span><span class=p>(</span><span class=no>REGS</span><span class=p>,</span> <span class=no>PUSH</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 3. 保存 CSRs
</span></span></span><span class=line><span class=cl>    <span class=nf>csrr</span> <span class=no>t0</span><span class=p>,</span> <span class=no>mcause</span>
</span></span><span class=line><span class=cl>    <span class=nf>csrr</span> <span class=no>t1</span><span class=p>,</span> <span class=no>mstatus</span>
</span></span><span class=line><span class=cl>    <span class=nf>csrr</span> <span class=no>t2</span><span class=p>,</span> <span class=no>mepc</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>STORE</span> <span class=no>t0</span><span class=p>,</span> <span class=no>OFFSET_CAUSE</span><span class=p>(</span><span class=no>sp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>STORE</span> <span class=no>t1</span><span class=p>,</span> <span class=no>OFFSET_STATUS</span><span class=p>(</span><span class=no>sp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>STORE</span> <span class=no>t2</span><span class=p>,</span> <span class=no>OFFSET_EPC</span><span class=p>(</span><span class=no>sp</span><span class=p>)</span>
</span></span></code></pre></div><p>这里的 MAP(REGS, PUSH) 宏会展开为一连串的 STORE 指令（sw 或 sd），将 CPU 里的通用寄存器一个个“搬运”到了内存堆栈中。此时，栈顶指针 sp 所指向的内存区域，就严格对应了 C 语言中的 Context 结构体。</p><p>软件（汇编宏指令）利用硬件（STORE）将硬件状态（寄存器）写入了内存。至此，“现在的我”被封存为一个 Context 结构体</p></li></ul><h4 id=c-语言核心处理>C 语言核心处理</h4><p>保存完毕后，汇编代码执行 <code>mv a0, sp</code>，将当前的栈顶地址（即刚才保存好的 <code>Context</code> 结构体的指针）作为参数，传递给 C 函数 <code>jal __am_irq_handle</code>。</p><ul><li><strong>事件分发 (<code>__am_irq_handle</code>):</strong><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// abstract-machine/am/src/riscv/nemu/cte.c
</span></span></span><span class=line><span class=cl><span class=n>Context</span><span class=o>*</span> <span class=nf>__am_irq_handle</span><span class=p>(</span><span class=n>Context</span> <span class=o>*</span><span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>user_handler</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Event</span> <span class=n>ev</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>mcause</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>case</span> <span class=mh>0x0b</span><span class=o>:</span> <span class=c1>// 对应 ecall
</span></span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>GPR1</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 检查 a7 是否为 -1
</span></span></span><span class=line><span class=cl>          <span class=n>ev</span><span class=p>.</span><span class=n>event</span> <span class=o>=</span> <span class=n>EVENT_YIELD</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=o>-&gt;</span><span class=n>mepc</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>;</span> <span class=c1>// 关键：将返回地址 +4，跳过 ecall 指令
</span></span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 核心调度点
</span></span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=nf>user_handler</span><span class=p>(</span><span class=n>ev</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol><li><strong>识别</strong>: 根据 <code>c->mcause</code> (0xb) 和 <code>c->GPR1</code> (-1)，识别出这是 <code>EVENT_YIELD</code>。</li><li><strong>修正</strong>: 执行 <code>c->mepc += 4</code>。这是因为 <code>mepc</code> 存的是 <code>ecall</code> 的地址，如果不加 4，返回后会死循环执行 <code>ecall</code>。</li><li><strong>调度</strong>: 调用 <code>user_handler(ev, c)</code>。<ul><li><code>user_handler</code>（在 <code>yield-test</code> 中是 <code>simple_trap</code>）接收了<strong>当前线程 A</strong> 的 Context 指针 <code>c</code>。</li><li>调度器可能会决定切换到<strong>线程 B</strong>。它会把线程 A 的 <code>c</code> 存起来，然后<strong>返回线程 B 的 Context 指针</strong>。</li><li>因此，<code>__am_irq_handle</code> 最后 <code>return c</code> 时，这个 <code>c</code> 已经指向了另一个线程的栈空间。</li></ul></li></ol></li></ul><h4 id=上下文恢复>上下文恢复</h4><p>C 函数返回后，回到了 <code>__am_asm_trap</code> 的后半部分。此时 <code>a0</code> 寄存器里装着<strong>目标线程</strong>的 Context 指针。</p><ul><li><p><strong>栈切换 (<code>mv a0, sp</code>):</strong>
这是最关键的一行汇编。<code>sp</code> 被修改为目标线程的上下文地址。这意味着我们从线程 A 的栈“跳”到了线程 B 的栈。</p></li><li><p><strong>恢复硬件状态:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=c1># abstract-machine/am/src/riscv/nemu/trap.S
</span></span></span><span class=line><span class=cl><span class=nl>__am_asm_trap:</span>
</span></span><span class=line><span class=cl>    <span class=na>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>mv</span> <span class=no>sp</span><span class=p>,</span> <span class=no>a0</span>          <span class=c1># 关键：切换栈指针到目标 Context
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 1. 恢复 CSRs (主要是 mstatus 和 mepc)
</span></span></span><span class=line><span class=cl>    <span class=nf>LOAD</span> <span class=no>t1</span><span class=p>,</span> <span class=no>OFFSET_STATUS</span><span class=p>(</span><span class=no>sp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>LOAD</span> <span class=no>t2</span><span class=p>,</span> <span class=no>OFFSET_EPC</span><span class=p>(</span><span class=no>sp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>csrw</span> <span class=no>mstatus</span><span class=p>,</span> <span class=no>t1</span>
</span></span><span class=line><span class=cl>    <span class=nf>csrw</span> <span class=no>mepc</span><span class=p>,</span> <span class=no>t2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 2. 恢复通用寄存器
</span></span></span><span class=line><span class=cl>    <span class=c1># 使用宏 MAP(REGS, POP) 自动展开为一系列 LOAD 指令
</span></span></span><span class=line><span class=cl>    <span class=nf>MAP</span><span class=p>(</span><span class=no>REGS</span><span class=p>,</span> <span class=no>POP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 3. 释放栈空间
</span></span></span><span class=line><span class=cl>    <span class=nf>addi</span> <span class=no>sp</span><span class=p>,</span> <span class=no>sp</span><span class=p>,</span> <span class=no>CONTEXT_SIZE</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 4. 硬件返回
</span></span></span><span class=line><span class=cl>    <span class=nf>mret</span>
</span></span></code></pre></div><p><code>MAP(REGS, POP)</code> 宏展开后的一系列 LOAD 指令将目标线程沉睡前保存的值重新装填进 CPU 寄存器。</p></li><li><p><strong>穿越完成 (<code>mret</code>):</strong>
最后执行 <code>mret</code> 指令。NEMU 硬件响应该指令：</p><ol><li><strong>恢复 PC</strong>: 将 <code>mepc</code> 的值（目标线程被打断时的下一条指令地址）写入 PC。</li><li><strong>特权级切换</strong>: 恢复机器模式状态。</li></ol><p>当 <code>mret</code> 执行完毕，CPU 的 PC 指向了目标代码，所有的寄存器也变回了目标线程的样子。对于目标线程而言，感觉就像是从 <code>yield()</code> 函数里“返回”了一样（实际上是刚从上一次的 <code>ecall</code> 后面返回）。</p></li></ul><h3 id=hello-程序是什么-它从而何来-要到哪里去>Hello 程序是什么, 它从而何来, 要到哪里去</h3><p><strong>问题：</strong> 我们知道 <code>navy-apps/tests/hello/hello.c</code> 只是一个 C 源文件&mldr; Hello 程序一开始在哪里? 它是怎么出现内存中的? 为什么会出现在目前的内存位置? 它的第一条指令在哪里? 究竟是怎么执行到它的第一条指令的? Hello 程序在不断地打印字符串, 每一个字符又是经历了什么才会最终出现在终端上?</p><p><strong>Solution:</strong></p><h4 id=从代码到静态-elf>从代码到静态 ELF</h4><ol><li><strong>编译与链接：</strong> 在 Navy-apps 环境下，通过交叉编译工具链，它被编译并链接成为 <strong>ELF (Executable and Linkable Format)</strong> 可执行文件。</li><li><strong>Ramdisk：</strong> 在目前的 PA 阶段，我们还没有真正的硬盘驱动。编译生成的 <code>hello</code> ELF 文件实际上被打包进了 Nanos-lite 的镜像中，或者更具体地说，它位于 <strong>Ramdisk</strong> (内存模拟磁盘) 中。在 <code>nanos-lite/src/resources.S</code> 中，<code>ramdisk.img</code> 被包含在内核的代码段/数据段中。</li></ol><ul><li>此时，Hello 程序只是 Ramdisk 这一大块字节串中，偏移量为 <code>0</code> (假设它是第一个文件) 的一段静止的二进制数据。</li></ul><h4 id=加载>加载</h4><ul><li><strong>加载过程 (<code>loader</code>)：</strong>
当 Nanos-lite 启动并决定运行 Hello 时，它调用 <code>loader()</code> 函数。<code>loader</code> 首先通过 <code>ramdisk_read</code> 读取 ELF Header，解析其中的 Program Header Table。</li><li><strong>内存位置的确定：</strong>
Loader 遍历 Program Header，寻找类型为 <code>PT_LOAD</code> 的段。它读取该段的 <code>VirtAddr</code> (虚拟内存地址) 和 <code>Offset</code> (文件偏移)。</li><li><strong>为什么是这里？</strong> 这个 <code>VirtAddr</code> (例如 MIPS/RISC-V 下通常是 <code>0x83000000</code> 附近) 并非随机选择，而是由 Navy-apps 编译时的 <strong>链接脚本 (<code>LD</code> script)</strong> 决定的。链接器约定了用户程序在内存中的位置，Loader 必须严格遵守这一约定，将代码和数据通过 <code>ramdisk_read</code> 拷贝到物理内存的对应位置。</li><li>对于 <code>.bss</code> 段（未初始化数据），Loader 还会根据 <code>MemSiz</code> 大于 <code>FileSiz</code> 的部分，将多出的内存空间清零。</li></ul><h4 id=跳转>跳转</h4><ul><li><strong>第一条指令 (<code>Entry Point</code>)：</strong>
ELF Header 中的 <code>e_entry</code> 字段记录了程序的入口地址。对于 Navy 程序，这个入口通常是 <code>_start</code> 函数（位于 <code>crt0.S</code>），它负责初始化 C 运行环境并调用 <code>main</code>。</li><li><strong>伪造现场 (Context Creation)：</strong>
Nanos-lite 并不会直接 <code>jmp</code> 到入口地址，而是采用了一种“欺骗”硬件的手段——<strong>构造中断上下文</strong>。
在 <code>naive_uload</code> 中，内核调用 <code>new_context</code> 创建一个陷阱上下文结构体 <code>Context</code>。最关键的一步是：将这个结构体中的 <code>mepc</code> (对于 RISC-V) 设置为 ELF 的入口地址 <code>e_entry</code>。</li><li><strong>执行第一条指令：</strong>
内核随后调用 <code>_switch</code> 或直接从中断处理函数返回。代码执行流进入 <code>trap.S</code> 的恢复逻辑（参考上一题“穿越时空的旅程”），最终执行 <strong><code>mret</code></strong> 指令。
硬件响应 <code>mret</code>，将 PC 寄存器强行设置为 <code>mepc</code> 的值（即 Hello 的入口地址），并将特权级切换回用户模式。
<strong>此刻，Hello 程序加载成功，CPU 开始执行它的第一条指令。</strong></li></ul><h4 id=执行>执行</h4><ol><li><strong>用户态 (Navy)：</strong>
<code>printf</code> 进行字符串格式化后，最终调用到 <code>libos/src/syscall.c</code> 中的 <strong><code>_write</code></strong> 函数。</li><li><strong>触发异常 (The Trap)：</strong>
<code>_write</code> 将系统调用号 (<code>SYS_write</code>)、文件描述符 (<code>stdout/1</code>)、缓冲区地址和长度放入约定好的寄存器（如 RISC-V 的 <code>a0</code>-<code>a7</code>），然后执行自陷指令 <strong><code>ecall</code></strong>。</li><li><strong>内核态 (Nanos-lite)：</strong>
CPU 捕获异常，保存上下文，跳转到 <code>__am_asm_trap</code>，最终进入 <code>do_syscall</code>。
<code>do_syscall</code> 从上下文中读取系统调用号，识别出这是 <code>SYS_write</code>。
对于 <code>fd == 1</code> (stdout) 的情况，内核调用 AM 提供的 <strong><code>putch</code></strong> 函数。</li><li><strong>硬件层 (NEMU)：</strong>
<code>putch</code> 实际上是向特定的 <strong>MMIO (内存映射 I/O)</strong> 地址（例如串口的数据寄存器地址）写入一个字节。
NEMU 的 <code>vmem</code> 模块监测到对该物理地址的写入操作，拦截该请求，并调用宿主机的 <code>putchar</code>，将字符打印在屏幕上。</li></ol><hr><h3 id=仙剑奇侠传究竟如何运行>仙剑奇侠传究竟如何运行</h3><p><strong>问题：</strong> 库函数, libos, Nanos-lite, AM, NEMU是如何相互协助, 来帮助仙剑奇侠传的代码从mgo.mkf文件中读出仙鹤的像素信息, 并且更新到屏幕上?</p><p><strong>Solution:</strong></p><p>整个过程是一次跨越计算机系统所有层次的接力跑。我们可以将仙鹤像素的旅程分为两个阶段：<strong>从文件到内存（读取阶段）</strong> 和 <strong>从内存到屏幕（显示阶段）</strong>。</p><h4 id=阶段一从-mgomkf-到用户缓冲区-读取>阶段一：从 mgo.mkf 到用户缓冲区 (读取)</h4><ol><li><strong>应用层 (User App): 发起请求</strong>
在 <code>PAL_SplashScreen()</code> 函数中，代码调用了 <code>PAL_MKFReadChunk(buf, ..., SPRITENUM_SPLASH_CRANE, gpGlobals->f.fpMGO)</code>。</li></ol><ul><li>这里的 <code>fpMGO</code> 是指向 <code>mgo.mkf</code> 的文件指针。</li><li>该函数内部会调用标准库函数 <code>fseek</code> 定位偏移量，然后调用 <code>fread</code> 请求读取数据。</li></ul><ol start=2><li><p><strong>库函数与 LibOS (libc & libos): 封装系统调用</strong>
<code>fread</code> 是 Newlib 提供的 C 标准库函数。它最终会调用底层系统调用接口 <code>_read</code>。
在 <code>navy-apps/libs/libos/src/syscall.c</code> 中，<code>_read</code> 将参数（系统调用号 <code>SYS_read</code>、文件描述符 <code>fd</code>、缓冲区地址 <code>buf</code>、长度 <code>len</code>）放入寄存器（如 RISC-V 的 <code>a0</code>-<code>a7</code>），并执行 <strong>自陷指令 (<code>ecall</code>)</strong>。</p></li><li><p><strong>操作系统 (Nanos-lite): 文件系统处理</strong>
CPU 响应自陷，切换到内核态，跳转到 <code>nanos-lite</code> 的异常处理入口 <code>do_syscall</code>。</p></li></ol><ul><li>内核识别出 <code>SYS_read</code>，调用 <code>fs_read</code>。</li><li><code>fs_read</code> 根据 <code>fd</code> 找到文件表中的 <code>mgo.mkf</code>，利用 <code>ramdisk_read</code>（因为目前文件系统基于 Ramdisk）从内存模拟的磁盘中，将仙鹤的压缩像素数据 <strong>拷贝 (<code>memcpy</code>)</strong> 到用户传入的缓冲区 <code>buf</code> 中。</li><li>读取完成后，内核通过 <code>mret</code> 返回用户态。</li></ul><ol start=4><li><strong>数据解压 (Computation)</strong>
回到应用层，<code>PAL_SplashScreen</code> 紧接着调用 <code>Decompress(buf, lpSpriteCrane, ...)</code>。这一步纯粹是 <strong>NEMU</strong> 执行通用指令，将压缩数据还原为原始像素数据，存放在 <code>lpSpriteCrane</code> 指向的内存中。</li></ol><h4 id=阶段二从用户缓冲区到屏幕-显示>阶段二：从用户缓冲区到屏幕 (显示)</h4><ol><li><p><strong>应用层 (User App): 准备画布</strong>
在循环中，程序计算仙鹤的坐标，调用 <code>PAL_RLEBlitToSurface</code> 将仙鹤的像素点画到一个软件模拟的 <code>SDL_Surface</code>（内存缓冲区）上。
最后，调用 <strong><code>VIDEO_UpdateScreen(NULL)</code></strong> 请求刷新屏幕。</p></li><li><p><strong>中间件 (NDL & MiniSDL): 抽象图形接口</strong>
<code>VIDEO_UpdateScreen</code> 属于 <code>libminiSDL</code>，它底层调用 <code>NDL_DrawRect</code> (Nanos-lite Display Library)。
<code>NDL_DrawRect</code> 将这一请求转化为对设备文件的写入操作：它打开（或复用）<code>/dev/fb</code>（帧缓冲设备），并调用 <code>write</code>。</p></li><li><p><strong>系统调用再次触发 (Trap)</strong>
类似于读取阶段，<code>write</code> 再次触发 <code>ecall</code>，陷入内核。这次的系统调用号是 <code>SYS_write</code>。</p></li><li><p><strong>操作系统 (Nanos-lite): 设备驱动</strong>
内核的 <code>do_syscall</code> 识别出 <code>SYS_write</code>。
<code>fs_write</code> 发现目标 <code>fd</code> 对应的是 <code>/dev/fb</code>，于是调用显示设备的写操作句柄（通常对应 <code>events.c</code> 或 <code>device.c</code> 中的 <code>fb_write</code>）。
<code>fb_write</code> 计算显存偏移量，最终调用 <strong>AM</strong> 提供的 IO 接口。</p></li><li><p><strong>抽象机器 (AM): 架构无关的 IO</strong>
AM 执行 <code>io_write(AM_GPU_FBDRAW, ...)</code>。在 NEMU 的实现中，这通常意味着将像素数据通过 <code>memcpy</code> 拷贝到一段特定的物理内存区域（<strong>VMEM</strong>，显存），或者写入特定的 <strong>MMIO</strong> 寄存器以触发同步。</p></li><li><p><strong>硬件模拟 (NEMU): 最终呈现</strong>
当 AM 写入 VMEM 时，数据实际上写入了 NEMU 申请的数组中。
NEMU 的 <code>vga_update_screen</code>（或类似函数）在每一帧结束时被调用，它读取这段 VMEM 数组，利用宿主机的图形库（SDL），将这些像素点真正的“画”在宿主机的窗口上。</p></li></ol><p><strong>总结：</strong>
仙鹤的像素数据，始于 <code>ramdisk</code> 的二进制流，经过 <code>fs_read</code> 的搬运进入用户内存，经由 CPU (<code>Decompress</code>) 的解压计算，再通过 <code>NDL</code> 和 <code>fb_write</code> 的层层封装，最终被写入显存，由 NEMU 的模拟硬件展示。这正是软件（Navy/Nanos-lite）、中间件（AM）与硬件（NEMU）紧密协作的结果。</p><h2 id=思考题>思考题</h2><h3 id=对比异常处理与函数调用>对比异常处理与函数调用</h3><p><strong>问题：</strong> 我们知道进行函数调用的时候也需要保存调用者的状态: 返回地址, 以及calling convention中需要调用者保存的寄存器. 而CTE在保存上下文的时候却要保存更多的信息. 尝试对比它们, 并思考两者保存信息不同是什么原因造成的</p><p><strong>Solution</strong>
两者保存信息的差异源于控制流转移的<strong>性质</strong>和<strong>目的</strong>不同。</p><h4 id=核心差异点>核心差异点</h4><table><thead><tr><th>机制</th><th><strong>函数调用 (Procedure Call)</strong></th><th><strong>异常/中断处理 (CTE)</strong></th></tr></thead><tbody><tr><td><strong>控制流</strong></td><td><strong>协作式</strong>，基于软件约定。</td><td><strong>非协作式</strong>，硬件或软件强制介入。</td></tr><tr><td><strong>特权级</strong></td><td>不切换。</td><td><strong>必须切换</strong>（用户态 \rightarrow 内核态）。</td></tr><tr><td><strong>保存范围</strong></td><td><strong>部分</strong>通用寄存器（最小必需子集）。</td><td><strong>全部</strong>通用寄存器（GPRs）+ 系统状态寄存器（CSRs）。</td></tr></tbody></table><h4 id=原因总结>原因总结</h4><ol><li><strong>非协作性：</strong> CTE 随时发生，内核无法预知哪些 GPRs 需要保留，因此必须保存<strong>所有</strong> GPRs，以保证被中断程序无损恢复。函数调用是软件约定好的，只需保存约定子集。</li><li><strong>特权级切换：</strong> CTE 涉及特权级提升，必须保存 <strong>CSRs</strong>（如 <code>mstatus</code> 和 <code>mepc</code>）来记录和恢复 CPU 的模式和状态。</li><li><strong>目的不同：</strong> CTE 旨在创建<strong>完整的进程/线程快照（Context）</strong>，这是操作系统实现<strong>进程调度</strong>和多任务的基础。</li></ol><h3 id=从加4操作看cisc和risc>从加4操作看CISC和RISC</h3><p><strong>问题：</strong> 决定 EPC 是否加 4 的是硬件还是软件？CISC/RISC 方案的取舍？哪个更合理？</p><p><strong>Solution:</strong></p><p>决定 EPC 修正的责任是<strong>硬件复杂性</strong>与<strong>软件灵活性</strong>的权衡。</p><table><thead><tr><th>方案</th><th><strong>CISC (硬件处理)</strong></th><th><strong>RISC (软件处理)</strong></th></tr></thead><tbody><tr><td><strong>机制</strong></td><td>硬件自动根据异常类型修正 EPC。</td><td>软件（内核）根据 <code>mcause</code> 手动修正 EPC。</td></tr><tr><td><strong>取舍</strong></td><td><strong>优点：</strong> 异常处理延迟极低。 <strong>缺点：</strong> 硬件复杂度高，指令集（ISA）扩展性差。</td><td><strong>优点：</strong> 硬件设计简单，ISA 统一精简，OS 灵活可控。 <strong>缺点：</strong> 异常处理延迟略高。</td></tr></tbody></table><p><strong>RISC 软件处理方案更合理。</strong>
<strong>理由：</strong> 它符合 RISC 哲学，将<strong>复杂性转移到低频发生的软件</strong>，从而简化 CPU 核心设计，提高 CPU 频率和效率。尽管异常延迟增加，但整体系统性能和可扩展性更高。</p><h3 id=如何识别不同格式的可执行文件>如何识别不同格式的可执行文件?</h3><p><strong>问题：</strong> 如果你在GNU/Linux下执行一个从Windows拷过来的可执行文件, 将会报告"格式错误". 思考一下, GNU/Linux是如何知道"格式错误"的?</p><p><strong>Solution</strong></p><p>GNU/Linux 内核通过 <strong><code>execve</code> 系统调用</strong>尝试加载文件时，通过校验文件头部的**魔数（Magic Number）**来识别格式。</p><ol><li><strong>内核操作：</strong> 当用户执行文件时，内核启动 <code>execve</code>，并读取文件开头的几个字节。</li><li><strong>魔数校验：</strong> 内核依次检查注册的<strong>可执行文件格式处理器（<code>binfmt</code>）</strong>。</li></ol><ul><li>Linux 原生格式是 <strong>ELF</strong>，其魔数为 \text{0x7FELF}。</li><li>Windows 文件是 <strong>PE</strong> 格式，其头部魔数与 ELF 不匹配。</li></ul><ol><li><strong>识别失败：</strong> 所有已注册的 <code>binfmt</code> 处理器（包括 <code>load_elf_binary</code>）都无法识别文件头部的魔数，导致加载失败。</li><li><strong>返回错误：</strong> 内核返回错误码 <strong><code>ENOEXEC</code></strong>（Exec format error）。Shell 将此翻译为用户可见的“格式错误”。</li></ol><h2 id=有趣的瞬间>有趣的瞬间</h2><p><img src=menu.png alt=menu></p><hr><p><img src=xianjianqixiazhuan1.png alt=仙界奇侠传(menu)1></p><hr><p><img src=xianjianqixiazhuan2.png alt=仙剑奇侠传(menu)2></p><hr><p><img src=nterm.png alt=nterm></p><hr><p><img src=xianjianqixiazhuan3.png alt=仙剑奇侠传(nterm)></p><h2 id=实验心情>实验心情</h2><p>😊 感觉良好</p></div></div><footer class=post-footer><div class=post-tags><a href=/tags/ics/ class=tag-link>#ICS</a>
<a href=/tags/pa/ class=tag-link>#PA</a></div></footer></div></article></section></div></main><footer class=footer data-liquid-glass=footer><div class=container><div class=footer-inner><div class=footer-info><p class=copyright>© 2025 - 2026 OCTOPUS</p><p class=powered>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> & Designed By Myself</p></div></div></div></footer><button class=fab-sidebar-toggle id=fabSidebarToggle aria-label=打开侧边栏>
<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class=sidebar-drawer id=sidebarDrawer><div class=sidebar-drawer-header><span class=sidebar-drawer-title>导航</span>
<button class=sidebar-drawer-close id=sidebarDrawerClose aria-label=关闭>
<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class=sidebar-drawer-content><div class=sidebar-inner><div class="sidebar-card blog-title-card"><a href=/ class=blog-title-link><span class=blog-title-text>DIMS</span></a></div><div class="sidebar-card profile-card"><div class=avatar><img src="https://avatars.githubusercontent.com/u/204014295?v=4" alt=OCTOPUS></div><div class=profile-info><h3>OCTOPUS</h3><p>热爱技术，热爱生活。</p></div><div class=profile-meta><span>Since 2025</span>
<span>github</span></div><nav class=mobile-nav><a href=/archives class=mobile-nav-link><span class=mobile-nav-icon>📁
</span><span>归档</span>
</a><a href=/gallery class=mobile-nav-link><span class=mobile-nav-icon>🖼️
</span><span>相册</span>
</a><a href=/moments class=mobile-nav-link><span class=mobile-nav-icon>📝
</span><span>日志</span>
</a><a href=/about class=mobile-nav-link><span class=mobile-nav-icon>👤
</span><span>关于</span></a></nav></div><div class=sidebar-card><h4 class=sidebar-title><a href=/categories/ class=sidebar-title-link><span class=title-icon>📁</span>
<span>分类</span></a></h4><ul class=sidebar-list><li><a href=/categories/%E6%8A%A5%E5%91%8A/ class=sidebar-link><span class=link-name>报告</span>
<span class=count>4</span></a></li></ul></div><div class=sidebar-card><h4 class=sidebar-title><a href=/tags/ class=sidebar-title-link><span class=title-icon>🏷️</span>
<span>标签</span></a></h4><div class=tag-cloud-compact><a href=/tags/ics/ class=tag-item-compact title="4 篇文章">ICS
</a><a href=/tags/pa/ class=tag-item-compact title="4 篇文章">PA</a></div></div><div class=sidebar-card><h4 class=sidebar-title><span class=title-icon>📝</span>
<span>最近文章</span></h4><ul class="sidebar-list recent-posts"><li><a href=/2026/02/09/ics_pa4-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/ class="sidebar-link recent-post-link"><span class="link-name recent-post-title">ICS_PA4 实验报告</span>
<span class=date>02-09</span></a></li><li><a href=/2025/12/12/ics_pa3-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/ class="sidebar-link recent-post-link"><span class="link-name recent-post-title">ICS_PA3 实验报告</span>
<span class=date>12-12</span></a></li><li><a href=/2025/11/11/ics_pa2-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/ class="sidebar-link recent-post-link"><span class="link-name recent-post-title">ICS_PA2 实验报告</span>
<span class=date>11-11</span></a></li><li><a href=/2025/09/24/ics_pa1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/ class="sidebar-link recent-post-link"><span class="link-name recent-post-title">ICS_PA1 实验报告</span>
<span class=date>09-24</span></a></li></ul></div></div></div></div><div class=sidebar-overlay id=sidebarOverlay></div><script src=/js/liquidGlass.min.js></script><script src=/js/main.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){typeof renderMathInElement!="undefined"&&renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\[",right:"\\]",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script></body></html>